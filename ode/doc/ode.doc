#########################################################################
#                                                                       #
# Open Dynamics Engine, Copyright (C) 2001,2002 Russell L. Smith.       #
# All rights reserved.  Email: russ@q12.org   Web: www.q12.org          #
#                                                                       #
# This library is free software; you can redistribute it and/or         #
# modify it under the terms of EITHER:                                  #
#   (1) The GNU Lesser General Public License as published by the Free  #
#       Software Foundation; either version 2.1 of the License, or (at  #
#       your option) any later version. The text of the GNU Lesser      #
#       General Public License is included with this library in the     #
#       file LICENSE.TXT.                                               #
#   (2) The BSD-style license that is included with this library in     #
#       the file LICENSE-BSD.TXT.                                       #
#                                                                       #
# This library is distributed in the hope that it will be useful,       #
# but WITHOUT ANY WARRANTY; without even the implied warranty of        #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files    #
# LICENSE.TXT and LICENSE-BSD.TXT for more details.                     #
#                                                                       #
#########################################################################

@title{Open Dynamics Engine v0.035 Pre-release User Guide}
@subtitle{Russell Smith, @date{}}
@author{Russell Smith, @date{}}

@center{This document is Copyright &copy; 2001,2002 Russell Smith.}
@center{This is an UNFINISHED document, there is still a lot of stuff
to write.}

@chapter{Contents @nonumber @nocontents}
@contents

#############################################################################
@chapter{Introduction}

The Open Dynamics Engine (ODE) is a free, industrial quality library for
simulating articulated rigid body dynamics.
For example, it is good for simulating ground vehicles, legged creatures,
and moving objects in VR environments.
It is fast, flexible and robust, and it has built-in collision detection.
ODE is being developed by @link{http://www.q12.org}{Russell Smith}.

If ``rigid body simulation'' does not make much sense to you, check out
@link{http://www.q12.org/ode/slides/slides.html}{What is a Physics SDK?}.

This is the user guide for the fourth prototype release of ODE (version 0.03).
This release is to help continue testing the core algorithms and solidifying
the API.
There will probably only be a few (hopefully minor) changes to the API in
the future.


@section{Current features}

ODE is best for simulating @emph{articulated} rigid body structures.
An articulated structure is created when rigid bodies of various shapes are
connected together with joints of various kinds.
Examples are ground vehicles (where the wheels are connected to the chassis)
or legged creatures (where the legs are connected to the body).

ODE is designed to be used in interactive or real-time simulation.
It is particularly good for simulating moving objects in changeable
virtual reality environments.
This is because it is fast, robust and stable, and the user has complete
freedom to change the structure of the system even while the simulation
is running.

# ODE can of course also simulate disconnected rigid bodies that just move
# around on their own and perhaps collide with each other, but it is not
# optimized for this case.
#    --- but it will be!

ODE uses a highly stable integrator, so that the simulation errors should
not grow out of control.
The physical meaning of this is that the simulated system should not
"explode" for no reason (believe me, this happens a lot with other simulators
if you are not careful).
ODE emphasizes speed and stability over physical accuracy.

ODE has @emph{hard} contacts. This means that a special non-penetration
constraint is used whenever two bodies collide.
The alternative, used in many other simulators, is to use virtual springs to
represent contacts.
This is difficult to do right and extremely error-prone.

ODE has a built-in collision detection system.
However you can ignore it and do your own collision detection if you want to.
The current collision primitives are sphere, box, capped cylinder and plane -
more collision objects will come later.
ODE's collision system provides fast identification of potentially
intersecting objects, through the concept of ``spaces''.

Here are the features:
@list{
@*	Arbitrary mass distribution of the rigid bodies.
@*	Current joint types: ball-and-socket, hinge, slider (prismatic),
	hinge-2, fixed, angular motor, universal.
@*	Current collision primitives: sphere, box, capped cylinder and plane.
@*	Simulation method: The equations of motion are derived from a
	Lagrange multiplier velocity based model due to Trinkle/Stewart and
	Anitescu/Potra.
@*	A first order integrator is being used. It's fast, but not accurate
	enough for quantitative engineering yet. Higher order integrators
	will come later.
@*	Contact and friction model: This is based on the Dantzig LCP solver
	described by Baraff, although ODE implements a faster approximation
	to the Coloumb friction model.
@*	Has a native C interface (even though ODE is mostly written in C++).
@*	Has a C++ interface built on top of the C one.
@*	Many unit tests, and more being written all the time.
@*	Platform specific optimizations.
@*	Other stuff I forgot to mention...
}


@section{New in the next release}

@list{
@* A universal joint, generously contributed by Martin C. Martin.
   It doesn't (yet) have a motor or joint limits.
}


@section{New in the 0.03 release}

@list{
@* Multi-resolution hash table based collision space, that performs quick
   identification of potentially intersecting pairs.
@* Improved the approximation to Coloumb friction.
@* Bug fixes.
@* New joint type: Angular Motor.
@* A few minor API changes so that the API matches the documentation.
@* LCP solver optimized even more.
@* A better build system.
@* Added the accessor functions: @func{dJointGetType()},
   @func{dBodyGetForce()}, @func{dBodyGetTorque()}, @func{dBodyGetNumJoints()},
   @func{dBodyGetJoint()}, @func{dJointGetBody()}.
@* Added finite rotation functions: @func{dBodySetFiniteRotationMode()}
   and @func{dBodySetFiniteRotationAxis()} (and the corresponding "get"
   functions).
@* New functions to set geometry parameters:
   @func{dGeomSphereSetRadius()}, @func{dGeomBoxSetLengths()},
   @func{dGeomPlaneSetParams()}, @func{dGeomCCylinderSetParams()}.
@* New collision utility function: @func{dInfiniteAABB()}.
@* Finally implemented the @c{dBodyAddXXX} functions. Also implemented
   @func{dBodyGetRelPointPos()} and @func{dBodyGetRelPointVel()}.
@* New geometry types: capped cylinder, GeomGroup, GeomTransform.
   Also a new documentation section on composite objects.
@* New functions for AABBs: @func{dGeomGetAABB()}, @func{dGeomGetSpaceAABB()}.
@* API change: geoms do not have to be added to a space on creation.
@* API change: user defined collision functions have to fill in the @c{g1}
   and @c{g2} members of the @c{dContactGeom} structure.
@* API change: added the @c{aabb_test} and @c{dtor} fields to @c{dGeomClass}.
@* Implemented capped-cylinder collision (except for cylinder-to-box).
@* Added @func{dMassAdd()}.
@* Ability to disable and enable bodies - see @func{dBodyEnable()},
   @func{dBodyDisable()}, @func{dBodyIsEnabled()}.
   See the new section: Concepts / Rigid bodies / Islands and disabled bodies.
}


@section{New in the 0.025 release}

@list{
@* Numerous bug fixes, including contacts.
@* Updated documentation.
@* Much more commenting in the source code.
@* Joint types: hinge, slider, ball and socket, hinge-2, fixed, contact.
@* Special vehicle joint: hinge-2 - with steering and suspension.
@* Powered hinge and slider joints (plus dry friction in those joints).
@* Joint limits for hinge and slider.
@* All contact modes work: bounce, soft, slip, restitution, tire slip.
@* CFM (constraint force mixing) framework.
@* New testing code.
@* New demo - buggy that you can drive around.
@* Cygwin (GNU on windows) builds now supported.
}


@section{New in the 0.02 release}

@list{
@* New demo: a box and sphere stacker.
@* Collision framework nearing stability.
@* Collision: all interactions of sphere, box, and plane now work.
@* 2D & 3D friction now works.
@* Framework now in place for more contact modes, powered and limited joints.
@* Moving-surface contact mode.
@* Argument checking for all functions.
@* Cross platform: build on windows using VC++ and MinGW, and linux.
@* Various bugs fixed.
}


@section{Future features}

@subsection{Plan for 0.035 release}

@list{
@* Update documentation.
@* Expose type-specific collision functions.
@* More collision primitives: transformation objects.
@* Improve box-box collision, especially for face-face contact.
@* Internals documentation.
@* Automatic code optimization process.
}

@subsection{Plan for 0.04 release}

@list{
@* Update documentation.
@* Static (still) groups not simulated.
@* SSE and 3DNow optimizations.
@* Implicit body damping, with reference velocity.
@* More collision primitives: flat-end cylinder? cone?
@* Higher order integrators for higher accuracy. Also force callback functions.
@* More internals documentation.
@* More joints.
}

@subsection{Other stuff for later releases}

@list{
@* Simulation tutorial, full documentation of internals and methods.
@* Collision: polyhedral objects, triangle soup.
@* Add reduced coordinate methods for a major speed improvement on
   tree-structured systems.
@* Thread safe.
}


@section{ODE's license}

ODE is Copyright &copy; 2001,2002 Russell L. Smith.
All rights reserved.

This library is free software; you can redistribute it and/or
modify it under the terms of EITHER:
@numlist{
@*	The @link{http://www.opensource.org/licenses/lgpl-license.html}{GNU
	Lesser General Public License} as published by the Free Software
	Foundation; either version 2.1 of the License, or (at your option)
	any later version. The text of the GNU Lesser General Public License
	is included with this library in the file @c{LICENSE.TXT}.
@*	The BSD-style license that is included with this library in
	the file @c{LICENSE-BSD.TXT}.
}
This library is distributed in the hope that it will be useful,
but @emph{WITHOUT ANY WARRANTY}; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files
@c{LICENSE.TXT} and @c{LICENSE-BSD.TXT} for more details.


@section{The ODE community}

Do you have questions or comments about ODE?
Think you can help? Please @link{http://q12.org/mailman/listinfo/ode}{write to
the ODE mailing list}.

#############################################################################
@chapter{How to install and use ODE}

@section{Installing ODE}

@b{Step 1:}
Unpack the ODE archive.

@b{Step 2:}
Get the GNU @c{make} tool. Many Unix platforms come with this, although
sometimes it is called @c{gmake}. I have provided a version of GNU make
for windows @link{http://q12.org/ode/bin/make.exe}{here}.

@b{Step 3:}
Edit the settings in the file @c{config/user-settings}.
The list of supported platforms is given in that file.

@b{Step 4:}
Run @c{make} to configure and build ODE and the graphical test programs.
Be @emph{sure} you are using the correct version of GNU make.
The make targets for building the parts of ODE are:
@list{
@* @c{make configure} : Create the configuration file @c{include/ode/config.h}.
@* @c{make ode-lib} : Build the core ODE library.
@* @c{make drawstuff-lib} : Build the OpenGL-based graphics library.
@* @c{make ode-test} : Build some ODE tests (they need drawstuff).
@* @c{make drawstuff-test} : Build a simple test app for the drawstuff library.
}
All of these targets will do an implicit @c{make configure}.
If the configurator screws up then you can edit the settings directly in
@c{include/ode/config.h}.

@b{Step 5:}
To install the ODE library onto your system you should copy the @c{lib/} and
@c{include/} directories to a suitable place, e.g. on Unix:
@list{
@* @c{include/ode/  --> /usr/local/include/ode/}
@* @c{lib/libode.a --> /usr/local/lib/libode.a}
}

There is currently no built-in support to build Windows DLLs or Unix shared
libraries --- although it is not hard to add this yourself.

ODE has been verified to build on at least the following platforms:
@list{
@* MS-Windows, Microsoft Visual C/C++ 6.
@* MS-Windows, MinGW (minimalist GNU for windows).
@* MS-Windows, CygWin (Cygnus GNU for windows).
@* Linux (x86, mandrake 8.1).
@* Linux (alpha, debian 2.2).
@* Linux (RS/6000, debian 2.2).
@* Linux (Sparc Ultra 60, debian 2.2).
@* FreeBSD 4.3.
@* Mac OS-X.
@* Solaris 8 (Sparc R220).
}


@section{Using ODE}

The best way to understand how to use ODE is to look at the test/example
programs that come with it. Note the following things:
@list{
@*	Source files that use ODE only need to include a single header file:
@code{@[
 #include <ode/ode.h>
@]}
	The @c{ode} directory in this statement is actually the 
	@c{include/ode} directory of the ODE distribution.
	This header file will include others in the @c{ode} directory,
	so you need to set the include path of your compiler,
	e.g. in linux
@code{@[
 gcc -c -I /home/username/ode/include myprogram.cpp
@]}

# NOT ANY MORE...
# @*	ODE can be compiled to use single or double precision variables.
#	To let the ODE header files know which precision is being used,
#	the user program must define one of the macros @c{dSINGLE} or
#	@c{dDOUBLE} before any ODE header files are included.
#	The easiest way to do this is on the compiler command line,
#	e.g. in linux
# @code{@[
#  gcc -c -I /home/username/ode/include -DdDOUBLE myprogram.cpp
# @]}

@*	ODE makes heavy use of the stack for storing temporary values.
	For very large systems several megabytes of stack can be used.
	If you experience unexplained out-of-memory errors or data
	corruption, especially on Windows, try increasing the stack size.
}

#############################################################################
@chapter{Concepts}

@section{Background}

[Here is where I will write some background information about rigid body
dynamics and simulation.
But in the meantime, please refer to Baraff's excellent
@link{http://www.cs.cmu.edu/~baraff/sigcourse/index.html}{SIGGRAPH tutorial}].


@section{Rigid bodies}

A rigid body has various properties from the point of view of the simulation.
Some properties change over time:
@list{
@*	Position vector (x,y,z) of the body's point of reference.
	Currently the point of reference must correspond to the body's
	center of mass.
@*	Linear velocity of the point of reference, a vector (vx,vy,vz).
@*	Orientation of a body, represented by a quaternion (qs,qx,qy,qz) or
	a 3x3 rotation matrix.
@*	Angular velocity vector (wx,wy,wz) which describes how the orientation
	changes over time.

}
Other body properties are usually constant over time:
@list{
@*	Mass of the body.
@*	Position of the center of mass with respect to the point of reference.
	In the current implementation the center of mass and the point of
	reference must coincide.
@*	Inertia matrix. This is a 3x3 matrix that describes how the body's
	mass is distributed around the center of mass.
}
Conceptually each body has an x-y-z coordinate frame embedded in it, that moves
and rotates with the body:

		@center{@picture{pix/body.jpg}}

The origin of this coordinate frame is the body's point of reference.
Some values in ODE (vectors, matrices etc) are relative to the body
coordinate frame, and others are relative to the global coordinate frame.

Note that the @emph{shape} of a rigid body is not a dynamical property
(except insofar as it influences the various mass properties).
It is only @emph{collision detection} that cares about the detailed shape of
the body.


@subsection{Islands and disabled bodies}

Bodies are connected to each other with joints.
An ``island'' of bodies is a group that can not be pulled apart - in other
words each body is connected somehow to every other body in the island.

Each island in the world is treated separately when the simulation step is
taken.
This is useful to know: if there are @m{N} similar islands in the
simulation then the step computation time will be @m{O(N)}.

Each body can be enabled or disabled.
Disabled bodies are effectively ``turned off'' and are not updated during a
simulation step.
Disabling bodies is an effective way to save computation time when it is known
that the bodies are motionless or otherwise irrelevent to the simulation.

If there are any enabled bodies in an island then every body in the island
will be enabled at the next simulation step.
Thus to effectively disable an island of bodies, @emph{every} body in the
island must be disabled.
If a disabled island is touched by another enabled body then the entire
island will be enabled, as a contact joint will join the enabled body to
the island.


@section{Integration}

The process of simulating the rigid body system through time is called
integration.
Each integration step advances the current time by a given step size,
adjusting the state of all the rigid bodies for the new time value.
There are two main issues to consider when working with any integrator:
@list{
@*	How accurate is it? That is, how closely does the behavior of the
	simulated system match what would happen in real life?
@*	How stable is it? That is, will calculation errors ever cause
	completely non-physical behavior of the simulated system?
	(e.g. causing the system to "explode" for no reason).
}
ODE's current integrator is very stable, but not particularly accurate
unless the step size is small.
For most uses of ODE this is not a problem -- ODE's behavior still looks
perfectly physical in almost all cases.
However ODE should not be used for quantitative engineering until this accuracy
issue has been addressed in a future release.


@section{Force accumulators}

Between each integrator step the user can call functions to apply forces
to the rigid body.
These forces are added to "force accumulators" in the rigid body object.
When the next integrator step happens, the sum of all the applied forces
will be used to push the body around.
The forces accumulators are set to zero after each integrator step.


@section{Joints and constraints}

In real life a joint is something like a hinge, that is used to connect two
objects.
In ODE a joint is very similar: It is a relationship that is enforced between
two bodies so that they can only have certain positions and orientations
relative to each other.
This relationship is called a @emph{constraint} -- the words @emph{joint} and
@emph{constraint} are often used interchangeably.
The following picture shows three different constraint types:

		@center{@picture{pix/joints.jpg}}

The first is a ball and socket joint that constraints the ``ball'' of one
body to be in the same location as the ``socket'' of another body.
The second is a hinge joint that constraints the two parts of the
hinge to be in the same location and to line up along the hinge axle.
The third is a slider joint that constraints the ``piston'' and ``socket''
to line up, and additionally constraints the two bodies to have the same
orientation.

Each time the integrator takes a step all the joints are allowed to apply
@emph{constraint forces} to the bodies they affect.
These forces are calculated such that the bodies move in such a way to
preserve all the joint relationships.

Each joint has a number of parameters controlling its geometry.
An example is the position of the ball-and-socket point for a ball-and-socket
joint.
The functions to set joint parameters all take @emph{global} coordinates,
not body-relative coordinates.
A consequence of this is that the rigid bodies that a joint connects must be
positioned correctly @emph{before} the joint is attached.


@section{Joint groups}

A joint group is a special container that holds joints in a world.
Joints can be added to a group, and then when those joints are no
longer needed the entire group of joints can be very quickly destroyed
with one function call.
However, individual joints in a group can not be destroyed before the entire
group is emptied.

This is most useful with contact joints, which are added and remove from
the world in groups every time step.


@section{Joint error and the error reduction parameter (ERP)}

When a joint attaches two bodies, those bodies are required to have certain
positions and orientations relative to each other.
However, it is possible for the bodies to be in positions where the joint
constraints are not met.
This ``joint error'' can happen in two ways:
@numlist{
@*	If the user sets the position/orientation of one body without correctly
	setting the position/orientation of the other body.
@*	During the simulation, errors can creep in that result in the bodies
	drifting away from their required positions.
}
Here is an example of error in a ball and socket joint (where the ball and
socket do not line up):

		@center{@picture{pix/ball-and-socket-bad.jpg}}

There is a mechanism to reduce joint error: during each simulation step each
joint applies a special force to bring its bodies back into correct alignment.
This force is controlled by the @emph{error reduction parameter} (ERP),
which has a value between 0 and 1.

The ERP specifies what proportion of the joint error will be
fixed during the next simulation step.
If ERP=0 then no correcting force is applied and the bodies will eventually
drift apart as the simulation proceeds.
If ERP=1 then the simulation will attempt to fix all joint error during the
next time step.
However, setting ERP=1 is not recommended, as the joint error will not be
completely fixed due to various internal approximations.
A value of ERP=0.1 to 0.8 is recommended (0.2 is the default).

A global ERP value can be set that affects most joints in the simulation.
However some joints have local ERP values that control various aspects of
the joint.


@section{Soft constraint and constraint force mixing (CFM)}

Most constraints are by nature ``hard''.
This means that the constraints represent conditions that are never violated.
For example, the ball must always be in the socket, and the two parts of the
hinge must always be lined up.
In practice constraints can be voilated by unintentional introduction of
errors into the system, but the error reduction parameter can be set to
correct these errors.

Not all constraints are hard.
Some ``soft'' constraints are designed to be violated.
For example, the contact constraint that prevents colliding objects from
penetrating is hard by default, so it acts as though the colliding surfaces
are made of steel.
But it can be made into a soft constraint to simulate softer materials,
thereby allowing some natural penetration of the two objects when they are
forced together.

There are two parameters that control the distinction between hard and soft
constraints. The first is the error reduction parameter (ERP) that has already
been introduced.
The second is the constraint force mixing (CFM) value, that is described below.


@subsection{Constraint force mixing (CFM)}

What follows is a somewhat technical description of the meaning of CFM.
If you just want to know how it is used in practice then skip to the next
section.

Traditionally the constraint equation for every joint has the form

	@center{@m{J * v = c}}

where @m{v} is a velocity vector for the bodies involved, @m{J} is a
``Jacobian'' matrix with one row for every degree of freedom the joint
removes from the system, and @m{c} is a right hand side vector.
At the next time step, a vector @m{lambda} is calculated (of the same
size as @m{c}) such that the forces applied to the bodies to preserve the
joint constraint are

	@center{@m{force = J^T * lambda}}

ODE adds a new twist.
ODE's constraint equation has the form

	@center{@m{J * v = c + CFM * lambda}}

where @m{CFM} is a square diagonal matrix.
@m{CFM} mixes the resulting constraint force in with the constraint that
produces it.
A nonzero (positive) value of @m{CFM} allows the original constraint
equation to be violated by an amount proportional to CFM times the restoring
force @m{lamda} that is needed to enforce the constraint.
Solving for @m{lambda} gives

	@center{@m{(J M^-^1 J^T + CFM/h) lambda = c/h}}

Thus @m{CFM} simply adds to the diagonal of the original system matrix.
Using a positive value of @m{CFM} has the additional benefit of taking the
system away from any singularity and thus improving the factorizer accuracy.


@subsection{How to use ERP and CFM}

ERP and CFM can be independently set in many joints. They can be set in
contact joints, in joint limits and various other places, to control the
spongyness and springyness of the joint (or joint limit).

If CFM is set to zero, the constraint will be hard.
If CFM is set to a positive value, it will be possible to violate the
constraint by ``pushing on it'' (for example, for contact constraints by
forcing the two contacting objects together).
In other words the constraint will be soft, and the softness will increase
as CFM increases.
What is actually happeneng here is that the constraint is allowed to be
violated by an amount proportional to CFM times the restoring force that is
needed to enforce the constraint.
Note that setting CFM to a negative value can have undesirable bad effects,
such as instability. Don't do it.

By adjusting the values of ERP and CFM, you can achieve various effects.
For example you can simulate springy constraints, where the two bodies
oscillate as though connected by springs.
Or you can simulate more spongy constraints, without the oscillation.
In fact, ERP and CFM can be selected to have the same effect as any
desired spring and damper constants.
If you have a spring constant @m{k_p} and damping constant @m{k_d},
then the corresponding ODE constants are:

	@center{ERP = h k_p / (h k_p + k_d)}
	@center{CFM = 1 / (h k_p + k_d)}

where @m{h} is the stepsize.
These values will give the same effect as a spring-and-damper system simulated
with implicit first order integration.

Increasing CFM, especially the global CFM, can reduce the numerical errors
in the simulation. If the system is near-singular, then this can markedly
increase stability.
In fact, if the system is mis-behaving, one of the first things to try is
to increase the global CFM.


@section{Collision handling}

[There is a lot that needs to be written about collision handling.]

Collisions between bodies or between bodies and the static environment are
handled as follows:
@numlist{
@*	Before each simulation step, the user calls collision detection
	functions to determine what is touching what.
	These functions return a list of contact points.
	Each contact point specifies a position in space, a surface normal
	vector, and a penetration depth.

@*	A special contact joint is created for each contact point.
	The contact joint is given extra information about the contact,
	for example the friction present at the contact surface, how bouncy
	or soft it is, and various other properties.

@*	The contact joints are put in a joint "group", which allows them to be
	added to and removed from the system very quickly.
	The simulation will speed goes down as the number of contacts goes up,
	so various strategies can be used to limit the number of contact
	points.

@*	A simulation step is taken.

@*	All contact joints are removed from the system.
}
Note that the built-in collision functions do not have to be used -
other collision detection libraries can be used as long as they provide
the right kinds of contact point information.


@section{Typical simulation code}

A typical simulation will proceed like this:
@numlist{
@*	Create a dynamics world.
@*	Create bodies in the dynamics world.
@*	Set the state (position etc) of all bodies.
@*	Create joints in the dynamics world.
@*	Attach the joints to the bodies.
@*	Set the parameters of all joints.
@*	Create a collision world and collision geometry objects, as
	necessary.
@*	Create a joint group to hold the contact joints.
@*	Loop: @numlist{
	@*	Apply forces to the bodies as necessary.
	@*	Adjust the joint parameters as necessary.
	@*	Call collision detection.
	@*	Create a contact joint for every collision point, and put it
		in the contact joint group.
	@*	Take a simulation step.
	@*	Remove all joints in the contact joint group.
	}
@*	Destroy the dynamics and collision worlds.
}


@section{Physics model}

The various methods and approximations that are used in ODE are discussed
here.

@subsection{Friction approximation}

[We really need more pictures here.]

The Coulomb friction model is a simple, but effective way to model friction
at contact points.
It is a simple relationship between the normal and tangential forces present
at a contact point (see the contact joint section for a description of these
forces). The rule is:

	@center{@m{| f_T | <= mu * | f_N |}}

where @m{f_N} and @m{f_T} are the normal and tangential force vectors
respectively, and @m{mu} is the friction coefficient (typically a number
around 1.0).
This equation defines a "friction cone" - imagine a cone with @m{f_N} as the
axis and the contact point as the vertex.
If the total friction force vector is within the cone then the contact is in
"sticking mode", and the friction force is enough to prevent the contacting
surfaces from moving with respect to each other.
If the force vector is on the surface of the cone then the contact is in
"sliding mode", and the friction force is typically not large enough to
prevent the contacting surfaces from sliding.
The parameter @m{mu} thus specifies the maximum ratio of tangential to normal
force.

ODE's friction models are approximations to the friction cone, for reasons of
efficiency. There are currently two approximations to chose from:
@numlist{
@*	The meaning of @m{mu} is changed so that it specifies the
	maximum friction (tangential) force that can be present at a contact,
	in either of the tangential friction directions.
	This is rather non physical because it is independent of the normal
	force, but it can be useful and it is the computationally cheapest
	option. Note that in this case @m{mu} is a force limit an must be
	chosen appropriate to the simulation.
@*	The friction cone is approximated by a friction pyramid aligned with
	the first and second friction directions [I really need a picture
	here].
	A further approximation is made: first ODE computes the normal forces
	assuming that all the contacts are frictionless. Then it computes the
	maximum limits @m{f_m} for the friction (tangential) forces from

		@center{@m{f_m = mu * | f_N |}} 

	and then proceeds to solve for the entire system with these fixed
	limits (in a manner similar to approximation 1 above).
	This differs from a true friction pyramid in that the "effective"
	@m{mu} is not quite fixed.
	This approximation is easier to use as @m{mu} is a unitless ratio
	the same as the normal Coloumb friction coefficient, and thus can be
	set to a constant value around 1.0 without regard for the specific
	simulation.
}

#############################################################################
@chapter{Data types and conventions}

@section{The basic data types}

The ODE library can be built to use either single or double precision floating
point numbers.
Single precision is faster and uses less memory, but the simulation will
have more numerical error that can result in visible problems.
You will get less accuracy and stability with single precision.

[must describe what factors influence accuracy and stability].

The floating point data type is @c{dReal}.
Other commonly used types are @c{dVector3}, @c{dVector4}, @c{dMatrix3},
@c{dMatrix4}, @c{dQuaternion}.


@section{Objects and IDs}

There are various kinds of object that can be created:
@list{
@*	dWorld - a dynamics world.
@*	dSpace - a collision space.
@*	dBody - a rigid body.
@*	dGeom - geometry (for collision).
@*	dJoint - a joint
@*	dJointGroup - a group of joints.
}
Functions that deal with these objects take and return object IDs.
The object ID types are @c{dWorldID}, @c{dBodyID}, etc.


@section{Argument conventions}

All 3-vectors (x,y,z) supplied to ``set'' functions are given as individual
x,y,z arguments.

All 3-vector result arguments to get() function are pointers to arrays of
@c{dReal}.

Larger vectors are always supplied and returned as pointers to arrays of
@c{dReal}.

All coordinates are in the global frame except where otherwise specified.


@section{C versus C++}

The ODE library is written in C++, but its public interface is made of simple
C functions, not classes. Why is this?
@list{
@*	Using a C interface only is simpler - the features of C++ features do
	not help much for ODE.
@*	It prevents C++ mangling and runtime-support problems across multiple
	compilers.
@*	The user doesn't have to be familiar with C++ quirks to use ODE.
}


@section{Debugging}

The ODE library can be compiled in "debugging" or "release" mode.
Debugging mode is slower, but function arguments are checked and many
run-time tests are done to ensure internal consistency.
Release mode is faster, but no checking is done.

#############################################################################
@chapter{World}

The world object is a container for rigid bodies and joints.
Objects in different worlds can not interact, for example rigid bodies from
two different worlds can not collide.

All the objects in a world exist at the same point in time, thus one reason
to use separate worlds is to simulate systems at different rates.

Most applications will only need one world.


@funcdef{
dWorldID dWorldCreate();
}{
Create a new, empty world and return its ID number.
}


@funcdef{
void dWorldDestroy (dWorldID);
}{
Destroy a world and everything in it. This includes all bodies, and all
joints that are not part of a joint group.
Joints that are part of a joint group will be deactivated, and can be
destroyed by calling, for example, @func{dJointGroupEmpty()}.
}


@funcdef{
void dWorldSetGravity (dWorldID, dReal x, dReal y, dReal z);
void dWorldGetGravity (dWorldID, dVector3 gravity);
}{
Set and get the world's global gravity vector. The units are m/s/s, so Earth's
gravity vector would be (0,0,-9.81), assuming that +z is up.
The default is no gravity, i.e. (0,0,0).
}


@funcdef{
void dWorldSetERP (dWorldID, dReal erp);
dReal dWorldGetERP (dWorldID);
}{
Set and get the global ERP value, that controls how much error correction is
performed in each time step.
Typical values are in the range 0.1--0.8.
The default is 0.2.
}


@funcdef{
void dWorldSetCFM (dWorldID, dReal cfm);
dReal dWorldGetCFM (dWorldID);
}{
Set and get the global CFM (constraint force mixing) value.
Typical values are in the range 1e-9 -- 1.
The default is 1e-5 if single precision is being used, or 1e-10 if double
precision is being used.
}


@funcdef{
void dWorldStep (dWorldID, dReal stepsize);
}{
Step the world.
}


@funcdef{
void dWorldImpulseToForce (dWorldID, dReal stepsize,
			   dReal ix, dReal iy, dReal iz, dVector3 force);
}{
If you want to apply a linear or angular impulse to a rigid body,
instead of a force or a torque, then you can use this function to convert
the desired impulse into a force/torque vector before calling the
@c{dBodyAdd...} function.

This function is given the desired impulse as (@arg{ix},@arg{iy},@arg{iz})
and puts the force vector in @arg{force}.
The current algorithm simply scales the impulse by 1/@arg{stepsize},
where @arg{stepsize} is the step size for the @emph{next} step that will
be taken.

This function is given a @c{dWorldID} because, in the future, the force
computation may depend on integrator parameters that are set as
properties of the world.
}


@funcdef{
void dCloseODE();
}{
This deallocates some extra memory used by ODE that can not be deallocated
using the normal destroy functions, e.g. @func{dWorldDestroy()}.
You can use this function at the end of your application to prevent
memory leak checkers from complaining about ODE.
}

#############################################################################
@chapter{Rigid body functions}

@section{Creating and destroying}

@funcdef{
dBodyID dBodyCreate (dWorldID);
}{
Create a body in the given world with default mass parameters at
position (0,0,0).
Return its ID.
}


@funcdef{
void dBodyDestroy (dBodyID);
}{
Destroy a body.
All joints that are attached to this body will be put into limbo
(i.e. unattached and not affecting the simulation, but they will NOT be
deleted).
}


@section{Position and orientation}

@funcdef{
void dBodySetPosition   (dBodyID, dReal x, dReal y, dReal z);
void dBodySetRotation   (dBodyID, const dMatrix3 R);
void dBodySetQuaternion (dBodyID, const dQuaternion q);
void dBodySetLinearVel  (dBodyID, dReal x, dReal y, dReal z);
void dBodySetAngularVel (dBodyID, dReal x, dReal y, dReal z);
const dReal * dBodyGetPosition   (dBodyID);
const dReal * dBodyGetRotation   (dBodyID);
const dReal * dBodyGetQuaternion (dBodyID);
const dReal * dBodyGetLinearVel  (dBodyID);
const dReal * dBodyGetAngularVel (dBodyID);
}{
These functions set and get the position, rotation, linear and angular
velocity of the body.
After setting a group of bodies, the outcome of the simulation is undefined
if the new configuration is inconsistent with the joints/constraints that are
present.
When getting, the returned values are pointers to internal data structures,
so the vectors are valid until any changes are made to the rigid body system
structure.

Hmmm. @c{dBodyGetRotation} returns a 4x3 rotation matrix.
}



@section{Mass and force}

@funcdef{
void dBodySetMass (dBodyID, const dMass *mass);
void dBodyGetMass (dBodyID, dMass *mass);
}{
Set/get the mass of the body (see the mass functions).
}


@funcdef{
void dBodyAddForce            (dBodyID, dReal fx, dReal fy, dReal fz);
void dBodyAddTorque           (dBodyID, dReal fx, dReal fy, dReal fz);
void dBodyAddRelForce         (dBodyID, dReal fx, dReal fy, dReal fz);
void dBodyAddRelTorque        (dBodyID, dReal fx, dReal fy, dReal fz);
void dBodyAddForceAtPos       (dBodyID, dReal fx, dReal fy, dReal fz,
                                        dReal px, dReal py, dReal pz);
void dBodyAddForceAtRelPos    (dBodyID, dReal fx, dReal fy, dReal fz,
                                        dReal px, dReal py, dReal pz);
void dBodyAddRelForceAtPos    (dBodyID, dReal fx, dReal fy, dReal fz,
                                        dReal px, dReal py, dReal pz);
void dBodyAddRelForceAtRelPos (dBodyID, dReal fx, dReal fy, dReal fz,
                                        dReal px, dReal py, dReal pz);
}{
Add forces to bodies (absolute or relative coordinates).
The forces are accumulated on to each body, and the accumulators are zeroed
after each time step.

The ...@c{RelForce} and ...@c{RelTorque} functions take force vectors that are
relative to the body's own frame of reference.

The ...@c{ForceAtPos} and ...@c{ForceAtRelPos} functions take an extra
position vector (in global or body-relative coordinates respectively)
that specifies the point at which the force is applied.
All other functions apply the force at the center of mass.
}


@funcdef{
const dReal * dBodyGetForce  (dBodyID);
const dReal * dBodyGetTorque (dBodyID);
}{
Return the current accumulated force and torque vector.
The returned pointers point to an array of 3 @c{dReal}s.
The returned values are pointers to internal data structures, so the vectors
are only valid until any changes are made to the rigid body system.
}


@funcdef{
void dBodySetForce  (dBodyID b, dReal x, dReal y, dReal z);
void dBodySetTorque (dBodyID b, dReal x, dReal y, dReal z);
}{
Set the body force and torque accumulation vectors.
This is mostly useful to zero the force and torque for deactivated bodies
before they are reactivated, in the case where the force-adding functions
were called on them while they were deactivated.
}


@section{Utility}

@funcdef{
void dBodyGetRelPointPos (dBodyID, dReal px, dReal py, dReal pz,
                          dVector3 result);
void dBodyGetRelPointVel (dBodyID, dReal px, dReal py, dReal pz,
                          dVector3 result);
void dBodyGetPointVel    (dBodyID, dReal px, dReal py, dReal pz,
                          dVector3 result);
}{
Utility functions that take a point on a body (@arg{px},@arg{py},@arg{pz}) and
return that point's position or velocity in global coordinates
(in @arg{result}).
The @c{dBodyGetRelPointXXX} functions are given the point in body
relative coordinates, and the @c{dBodyGetPointVel} function is given
the point in global coordinates.
}


@funcdef{
void dBodyGetPosRelPoint (dBodyID, dReal px, dReal py, dReal pz,
                       	  dVector3 result);
}{
This is the inverse of @func{dBodyGetRelPointPos()}.
It takes a point in global coordinates (@arg{x},@arg{y},@arg{z}) and returns
the point's position in body-relative coordinates (@arg{result}).
}


@funcdef{
void dBodyVectorToWorld   (dBodyID, dReal px, dReal py, dReal pz,
                           dVector3 result);
void dBodyVectorFromWorld (dBodyID, dReal px, dReal py, dReal pz,
                           dVector3 result);
}{
Given a vector expressed in the body (or world) coordinate system
(@arg{x},@arg{y},@arg{z}), rotate it to the world (or body) coordinate system
(@arg{result}).
}


@section{Miscellaneous}

@funcdef{
void  dBodySetData (dBodyID, void *data);
void *dBodyGetData (dBodyID);
}{
Get and set the body's user-data pointer.
}


@funcdef{
void dBodyEnable (dBodyID);
void dBodyDisable (dBodyID);
int dBodyIsEnabled (dBodyID);
}{
Enable and disable a body.
Disabled bodies are effectively ``turned off'' and are not updated during a
simulation step.
However, if a disabled body is connected to island containing one or more
enabled bodies then it will be re-enabled at the next simulation step.

@c{dBodyIsEnabled} return 1 if a body is enabled or 0 if it is disabled.
New bodies are created in the enabled state.
}


@funcdef{
void dBodySetFiniteRotationMode (dBodyID, int mode);
}{
This function control the way a body's orientation is updated at each time
step. The @arg{mode} argument can be:
@list{
@*	0: An ``infitesimal'' orientation update is used.
	This is fast to compute, but it can occasionally cause inaccuracies
	for bodies that are rotating at high speed, especially when those
	bodies are joined to other bodies.
	This is the default for every new body that is created.
@*	1: A ``finite'' orientation update is used.
	This is more costly to compute, but will be more accurate for high
	speed rotations.
	Note however that high speed rotations can result in many types of
	error in a simulation, and this mode will only fix one of those
	sources of error.
}
}


@funcdef{
int dBodyGetFiniteRotationMode (dBodyID);
}{
Return the current finite rotation mode of a body (0 or 1).
}


@funcdef{
void dBodySetFiniteRotationAxis (dBodyID, dReal x, dReal y, dReal z);
}{
This sets the finite rotation axis for a body.
This is axis only has meaning when the finite rotation mode is set
(see @func{dBodySetFiniteRotationMode()}).

If this axis is zero (0,0,0), full finite rotations are performed on the body.

If this axis is nonzero, the body is rotated by performing a partial finite
rotation along the axis direction followed by an infitesimal rotation along
an orthogonal direction.

This can be useful to alleviate certain sources of error caused by quickly
spinning bodies. For example, if a car wheel is rotating at high speed
you can call this function with the wheel's hinge axis as the argument to
try and improve its behavior.
}


@funcdef{
void dBodyGetFiniteRotationAxis (dBodyID, dVector3 result);
}{
Return the current finite rotation axis of a body.
}


@funcdef{
int dBodyGetNumJoints (dBodyID b);
}{
Return the number of joints that are attached to this body.
}


@funcdef{
dJointID dBodyGetJoint (dBodyID, int index);
}{
Return a joint attached to this body, given by @arg{index}.
Valid indexes are 0 to @m{n}-1 where @m{n} is the value returned by
@func{dBodyGetNumJoints()}.
}


@funcdef{
void dBodySetGravityMode (dBodyID b, int mode);
int dBodyGetGravityMode (dBodyID b);
}{
Set/get whether the body is influenced by the world's gravity or not.
If @arg{mode} is nonzero it is, if @arg{mode} is zero, it isn't.
Newly created bodies are always influenced by the world's gravity.
}

#############################################################################
@chapter{Joint types and joint functions}

@section{Creating and destroying}

@funcdef{
dJointID dJointCreateBall (dWorldID, dJointGroupID);
dJointID dJointCreateHinge (dWorldID, dJointGroupID);
dJointID dJointCreateSlider (dWorldID, dJointGroupID);
dJointID dJointCreateContact (dWorldID, dJointGroupID,
                              const dContact *);
dJointID dJointCreateUniversal (dWorldID, dJointGroupID);
dJointID dJointCreateHinge2 (dWorldID, dJointGroupID);
dJointID dJointCreateFixed (dWorldID, dJointGroupID);
dJointID dJointCreateAMotor (dWorldID, dJointGroupID);
}{
Create a new joint of a given type.
The joint is initially in "limbo" (i.e. it has no effect on the simulation)
because it does not connect to any bodies.
The joint group ID is 0 to allocate the joint normally.
If it is nonzero the joint is allocated in the given joint group.
The contact joint will be initialized with the given @struct{dContact}
structure.
}


@funcdef{
void dJointDestroy (dJointID);
}{
Destroy a joint, disconnecting it from its attached bodies and removing
it from the world.
However, if the joint is a member of a group then this function has no
effect - to destroy that joint the group must be emptied or destroyed.
}


@funcdef{
dJointGroupID dJointGroupCreate (int max_size);
}{
Create a joint group.
The @arg{max_size} argument is now unused and should be set to 0.
It is kept for backwards compatibility.
}


@funcdef{
void dJointGroupDestroy (dJointGroupID);
}{
Destroy a joint group. All joints in the joint group will be destroyed.
}


@funcdef{
void dJointGroupEmpty (dJointGroupID);
}{
Empty a joint group. All joints in the joint group will be destroyed,
but the joint group itself will not be destroyed.
}


@section{Miscellaneous}

@funcdef{
void dJointAttach (dJointID, dBodyID body1, dBodyID body2);
}{
Attach the joint to some new bodies.
If the joint is already attached, it will be detached from the old bodies
first.
To attach this joint to only one body, set body1 or body2 to zero - a zero
body refers to the static environment.
Setting both bodies to zero puts the joint into "limbo", i.e. it will
have no effect on the simulation.

Some joints, like hinge-2 need to be attached to two bodies to work.
}


@funcdef{
void dJointSetData (dJointID, void *data);
void *dJointGetData (dJointID);
}{
Get and set the joint's user-data pointer. 
}


@funcdef{
int dJointGetType (dJointID);
}{
Get the joint's type. One of the following constants will be returned:

@constdef{dJointTypeBall}{A ball-and-socket joint.}
@constdef{dJointTypeHinge}{A hinge joint.}
@constdef{dJointTypeSlider}{A slider joint.}
@constdef{dJointTypeContact}{A contact joint.}
@constdef{dJointTypeUniversal}{A universal joint.}
@constdef{dJointTypeHinge2}{A hinge-2 joint.}
@constdef{dJointTypeFixed}{A fixed joint.}
@constdef{dJointTypeAMotor}{An angular motor joint.}
}


@funcdef{
dBodyID dJointGetBody (dJointID, int index);
}{
Return the bodies that this joint connects. The @arg{index} must be either 0
or 1, referring to either the ``first'' or ``second'' body.
If one of these returned body IDs is zero, the joint connects the other body
to the static environment.
If both body IDs are zero, the joint is in ``limbo'' and has no effect on
the simulation.
}


@funcdef{
void dJointSetFeedback (dJointID, dJointFeedback *);
dJointFeedback *dJointGetFeedback (dJointID);
}{
During the world time step, the forces that are applied by each joint are
computed. These forces are added directly to the joined bodies, and the user
normally has no way of telling which joint contributed how much force.

If this information is desired then the user can allocate a @c{dJointFeedback}
structure and pass its pointer to the @c{dJointSetFeedback()} function.
The feedback information structure is defined as follows:

@code{@[
typedef struct dJointFeedback {
  dVector3 f1;       // force that joint applies to body 1
  dVector3 t1;       // torque that joint applies to body 1
  dVector3 f2;       // force that joint applies to body 2
  dVector3 t2;       // torque that joint applies to body 2
} dJointFeedback;
@]}

During the time step any feedback structures that are attached to joints will
be filled in with the joint's force and torque information.
The @c{dJointGetFeedback()} function returns the current feedback
structure pointer, or 0 if none is used (this is the default).
@c{dJointSetFeedback()} can be passed 0 to disable feedback for that joint.

Now for some API design notes.
It might seem strange to require that users perform the allocation of
these structures. Why not just store the data statically in each
joint? The reason is that not all users will use the feedback
information, and even when it is used not all joints will need it.
It will waste memory to store it statically, especially as this
structure could grow to store a lot of extra information in the
future.

Why not have ODE allocate the structure itself, at the user's request?
The reason is that contact joints (which are created and destroyed
every time step) would require a lot of time to be spent in memory
allocation if feedback is required. Letting the user do the allocation
means that a better allocation strategy can be provided, e.g simply
allocating them out of a fixed array.

The alternative to this API is to have a joint-force callback. This
would work of course, but it has a few problems. First, callbacks tend
to pollute APIs and sometimes require the user to go through unnatural
contortions to get the data to the right place. Second, this would
expose ODE to being changed in the middle of a step (which
would have bad consequences), and there would have to be some kind of
guard against this or a debugging check for it - which would complicate
things.
}


@funcdef{
int dAreConnected (dBodyID, dBodyID);
}{
Utility function: return 1 if the two bodies are connected together by
a joint, otherwise return 0.
}



@section{Joint parameter setting functions}

@subsection{Ball and socket}

A ball and socket joint looks like this:

		@center{@picture{pix/ball-and-socket.jpg}}

@funcdef{
void dJointSetBallAnchor (dJointID, dReal x, dReal y, dReal z);
}{
Set the joint anchor point.
}

@funcdef{
void dJointGetBallAnchor (dJointID, dVector3 result);
}{
Get the joint anchor point.
}


@subsection{Hinge}

A hinge joint looks like this:

		@center{@picture{pix/hinge.jpg}}


@funcdef{
void dJointSetHingeAnchor (dJointID, dReal x, dReal y, dReal z);
void dJointSetHingeAxis (dJointID, dReal x, dReal y, dReal z);
}{
Set hinge anchor and axis parameters.
}


@funcdef{
void dJointGetHingeAnchor (dJointID, dVector3 result);
void dJointGetHingeAxis (dJointID, dVector3 result);
}{
Get hinge anchor and axis parameters.
}


@funcdef{
dReal dJointGetHingeAngle (dJointID);
dReal dJointGetHingeAngleRate (dJointID);
}{
Get the hinge angle and the time derivative of this value.
The angle is measured between the two bodies, or between the body and
the static environment.
The angle will be between -pi..pi.

When the hinge anchor or axis is set, the current position of the attached
bodies is examined and that position will be the zero angle.
}



@subsection{Slider}

A slider joint looks like this:

		@center{@picture{pix/slider.jpg}}

@funcdef{
void dJointSetSliderAxis (dJointID, dReal x, dReal y, dReal z);
}{
Set the slider axis parameter.
}


@funcdef{
void dJointGetSliderAxis (dJointID, dVector3 result);
}{
Get the slider axis parameter.
}


@funcdef{
dReal dJointGetSliderPosition (dJointID);
dReal dJointGetSliderPositionRate (dJointID);
}{
Get the slider linear position (i.e. the slider's ``extension'') and the time
derivative of this value.

When the axis is set, the current position of the attached bodies is
examined and that position will be the zero position.
}


@subsection{Universal}

A universal joint looks like this:

		@center{@picture{pix/universal.jpg}}

A universal joint is like a ball and socket joint that constrains an
extra degree of rotational freedom. Given axis 1 on body 1, and axis 2
on body 2 that is perpendicular to axis 1, it keeps them
perpendicular. In other words, rotation of the two bodies about the
direction perpendicular to the two axes will be equal.

In the picture, the two bodies are joined together by a cross. Axis 1
is attached to body 1, and axis 2 is attached to body 2. The cross
keeps these axes at 90 degrees, so if you grab body 1 and twist it,
body 2 will twist as well.

Universal joints show up in cars, where the engine causes a shaft, the
drive shaft, to rotate along its own axis. At some point you'd like to
change the direction of the shaft. The problem is, if you just bend
the shaft, then the part after the bend won't rotate about its own
axis. So if you cut it at the bend location and insert a universal
joint, you can use the constraint to force the second shaft to rotate
about the same angle as the first shaft.

Another use of this joint is to attach the arms of a simple virtual
creature to its body. Imagine a person holding their arms straight
out. You may want the arm to be able to move up and down, and forward
and back, but not to rotate about its own axis.

Here are the universal joint functions:

@funcdef{
void dJointSetUniversalAnchor (dJointID, dReal x, dReal y, dReal z);
void dJointSetUniversalAxis1 (dJointID, dReal x, dReal y, dReal z);
void dJointSetUniversalAxis2 (dJointID, dReal x, dReal y, dReal z);
void dJointGetUniversalAnchor (dJointID, dVector3 result);
void dJointGetUniversalAxis1 (dJointID, dVector3 result);
void dJointGetUniversalAxis2 (dJointID, dVector3 result);
}{
FIXME: I should eventually write a description of these functions here.
}


@subsection{Hinge-2}

A hinge-2 joint looks like this:

		@center{@picture{pix/hinge2.jpg}}

The hinge-2 joint is the same as two hinges connected in series, with
different hinge axes.
An example, shown in the above picture is the steering wheel of a car,
where one axis allows the wheel to be steered and the other axis allows
the wheel to rotate.

The hinge-2 joint has an anchor point and two hinge axes.
Axis 1 is specified relative to body 1 (this would be the steering axis if
body 1 is the chassis).
Axis 2 is specified relative to body 2 (this would be the wheel axis if
body 2 is the wheel).

Axis 1 can have joint limits and a motor, axis 2 can only have a motor.

Axis 1 can function as a suspension axis, i.e. the constraint can be
compressible along that axis.



@funcdef{
void dJointSetHinge2Anchor (dJointID, dReal x, dReal y, dReal z);
void dJointSetHinge2Axis1 (dJointID, dReal x, dReal y, dReal z);
void dJointSetHinge2Axis2 (dJointID, dReal x, dReal y, dReal z);
}{
Set hinge-2 anchor and axis parameters.
Axis 1 and axis 2 must not lie along the same line.
}


@funcdef{
void dJointGetHinge2Anchor (dJointID, dVector3 result);
void dJointGetHinge2Axis1 (dJointID, dVector3 result);
void dJointGetHinge2Axis2 (dJointID, dVector3 result);
}{
Get hinge-2 anchor and axis parameters.
}


@funcdef{
dReal dJointGetHinge2Angle1 (dJointID);
dReal dJointGetHinge2Angle1Rate (dJointID);
dReal dJointGetHinge2Angle2Rate (dJointID);
}{
Get the hinge-2 angles (around axis 1 and axis 2) and the time derivatives
of these values.

When the anchor or axis is set, the current position of the attached
bodies is examined and that position will be the zero angle.
}


@subsection{Fixed}

The fixed joint maintains a fixed relative position and orientation between
two bodies, or between a body and the static environment.
Using this joint is almost never a good idea in practice, except when
debugging.
If you need two bodies to be glued together it is better to represent that as
a single body.

Currently the fixed joint does not support a non-identity relative rotation
between two bodies, it only supports a relative offset.

@funcdef{
void dJointSetFixed (dJointID);
}{
Call this on the fixed joint after it has been attached to remember the
current desired relative offset between the bodies.
}


@subsection{Contact}

A contact joint looks like this:

		@center{@picture{pix/contact.jpg}}

The contact joint prevents body 1 and body 2 from inter-penetrating at the
contact point.
It does this by only allowing the bodies to have an ``outgoing'' velocity
in the direction of the contact normal.
Contact joints typically have a lifetime of one time step.
They are created and deleted in response to collision detection.

Contact joints can simulate friction at the contact by applying special
forces in the two friction directions that are perpendicular to the
normal.

When a contact joint is created, a @c{dContact} structure must be supplied.
This has the following definition:
@code{@[
struct dContact {
  dSurfaceParameters surface;
  dContactGeom geom;
  dVector3 fdir1;
};
@]}
@c{geom} is a substructure that is set by the collision functions.
It is described in the collision section.

@c{fdir1} is a "first friction direction" vector that defines a direction
along which frictional force is applied.
It must be of unit length and perpendicular to the contact normal
(so it is typically tangential to the contact surface).
It should only be defined if the @const{dContactFDir1} flag is set in
@c{surface.mode}.
The "second friction direction" is a vector computed to be perpendicular to
both the contact normal and @c{fdir1}.

@c{surface} is a substructure that is set by the user.
Its members define the properties of the colliding surfaces.
It has the following members:
@list{
@*	@c{int mode} - Contact flags. This must always be defined.
	This is a combination of one or more of the following flags:

	@constdef{dContactMu2}{If not set, use @c{mu} for both friction
		directions. If set, use @c{mu} for friction direction 1,
		use @c{mu2} for friction direction 2.}
	@constdef{dContactFDir1}{If set, take @c{fdir1} as friction direction
		1, otherwise compute friction direction 1 to be perpendicular
		to the contact normal (in which case its resulting orientation
		is not defined).}
	@constdef{dContactBounce}{If set, the contact surface is bouncy,
		in other words the bodies will bounce off each other.
		The exact amount of bouncyness is controlled by the
		@c{bounce} parameter.}
	@constdef{dContactSoftERP}{If set, the error reduction parameter of
		the contact normal can be set with the @c{soft_erp} parameter.
		This is useful to make surfaces soft.}
	@constdef{dContactSoftCFM}{If set, the constraint force mixing
		parameter of the contact normal can be set with the
		@c{soft_cfm} parameter. This is useful to make surfaces soft.}
	@constdef{dContactMotion1}{If set, the contact surface is assumed to
		be moving independently of the motion of the bodies.
		This is kind of like a conveyor belt running over the surface.
		When this flag is set, @c{motion1} defines the surface
		velocity in friction direction 1.}
	@constdef{dContactMotion2}{The same thing as above, but for
		friction direction 2.}
	@constdef{dContactSlip1}{Slip, friction direction 1.
		[this needs more description].}
	@constdef{dContactSlip2}{Slip, friction direction 2.
		[this needs more description].}
	@constdef{dContactApprox1_1}{Use the friction pyramid approximation
		for friction direction 1. If this is not specified then the
		constant-force-limit approximation is used (and @c{mu} is a
		force limit).}
	@constdef{dContactApprox1_2}{Use the friction pyramid approximation
		for friction direction 2. If this is not specified then the
		constant-force-limit approximation is used (and @c{mu} is a
		force limit).}
	@constdef{dContactApprox1}{Equivalent to both @c{dContactApprox1_1}
		and @c{dContactApprox1_2}.}

@*	@c{dReal mu} : Coulomb friction coefficient.
	This must be in the range 0 to @c{dInfinity}. 0 results in a
	frictionless contact, and @c{dInfinity} results in a contact that
	never slips.
	Note that frictionless contacts are less time consuming to compute
	than ones with friction, and infinite friction contacts can be cheaper
	than contacts with finite friction.
	This must always be defined.

@*	@c{dReal mu2} : Optional Coulomb friction coefficient for friction
		direction 2 (0..@c{dInfinity}). This is only defined if the
		corresponding flag is set is @c{mode}.

@*	@c{dReal bounce} : Restitution parameter (0..1).
	0 means the surfaces are not bouncy at all, 1 is maximum bouncyness.
	This is only defined if the corresponding flag is set is @c{mode}.

@*	@c{dReal bounce_vel} : The minimum incoming velocity necessary for
	bounce (in m/s). Incoming velocities below this will effectively have
	a bounce parameter of 0.
	This is only defined if the corresponding flag is set is @c{mode}.

@*	@c{dReal soft_erp} : Contact normal ``softness'' parameter.
	This is only defined if the corresponding flag is set is @c{mode}.

@*	@c{dReal soft_cfm} : Contact normal ``softness'' parameter.
	This is only defined if the corresponding flag is set is @c{mode}.

@*	@c{dReal motion1,motion2} : Surface velocity in friction directions
	1/2 (m/s).
	This is only defined if the corresponding flag is set is @c{mode}.

@*	@c{dReal slip1,slip2} : First order slip in friction directions 1/2.
	This is only defined if the corresponding flag is set is @c{mode}.
}


@subsection{Angular Motor}

An angular motor (AMotor) allows the relative angular velocities of two
bodies to be controlled.
The angular velocity can be controlled on up to three axes, allowing
torque motors and stops to be set for rotation about those axes
(see the ``Stops and motor parameters'' section below).
This is mainly useful in conjunction will ball joints (which do not
constrain the angular degrees of freedom at all), but it can be used in
any situation where angular control is needed.
To use an AMotor with a ball joint, simply attach it to the same two bodies
that the ball joint is attached to.

The AMotor can be used in different modes.
In @c{dAMotorUser} mode, the user directly sets the axes that the AMotor
controls.
In @c{dAMotorEuler} mode, AMotor computes the @emph{euler angles}
corresponding to the relative rotation, allowing euler angle torque motors
and stops to be set.
An AMotor joint with euler angles looks like this:

		@center{@picture{pix/amotor.jpg}}

In this diagram, @m{a_0}, @m{a_1} and @m{a_2} are the three axes along
which angular motion is controlled.
The green axes (including @m{a_0}) are anchored to body 1.
The blue axes (including @m{a_2}) are anchored to body 2.
To get the body 2 axes from the body 1 axes the following sequence of
rotations is performed:
@list{
@*	Rotate by @m{theta_0} about @m{a_0}.
@*	Rotate by @m{theta_1} about @m{a_1} (@m{a_1} has been rotated from its
	original position).
@*	Rotate by @m{theta_2} about @m{a_2} (@m{a_2} has been rotated twice
	from its original position).
}

There is an important restriction when using euler angles: the @m{theta_1}
angle must not be allowed to get outside the range @m{-pi/2 ... pi/2}.
If this happens then the AMotor joint will become unstable (there is a
singularity at @m{+/- pi/2}).
Thus you must set the appropriate stops on axis number 1.


@funcdef{
void dJointSetAMotorMode (dJointID, int mode);
int dJointGetAMotorMode (dJointID);
}{
Set (and get) the angular motor mode. The @arg{mode} parameter must be one
of the following constants:

@constdef{dAMotorUser}{The AMotor axes and joint angle settings are entirely
	controlled by the user.
	This is the default mode.}
@constdef{dAMotorEuler}{Euler angles are automatically computed.
	The axis @m{a_1} is also automatically computed.
	The AMotor axes must be set correctly when in this mode,
	as described below.
	When this mode is initially set the current relative orientations
	of the bodies will correspond to all euler angles at zero.
	}
}

@funcdef{
void dJointSetAMotorNumAxes (dJointID, int num);
int dJointGetAMotorNumAxes (dJointID);
}{
Set (and get) the number of angular axes that will be controlled by the
AMotor.
The argument @arg{num} can range from 0 (which effectively deactivates the
joint) to 3.
This is automatically set to 3 in @c{dAMotorEuler} mode.
}

@funcdef{
void dJointSetAMotorAxis (dJointID, int anum, int rel,
			  dReal x, dReal y, dReal z);
void dJointGetAMotorAxis (dJointID, int anum, dVector3 result);
int dJointGetAMotorAxisRel (dJointID, int anum);
}{
Set (and get) the AMotor axes.
The @arg{anum} argument selects the axis to change (0,1 or 2).
Each axis can have one of three ``relative orientation'' modes, selected by
@arg{rel}:
@list{
@* 0: The axis is anchored to the global frame.
@* 1: The axis is anchored to the first body.
@* 2: The axis is anchored to the second body.
}
The axis vector (@arg{x},@arg{y},@arg{z}) is always specified in global
coordinates regardless of the setting of @arg{rel}.
There are two @c{GetAMotorAxis} functions, one to return the axis and one to
return the relative mode.

For @c{dAMotorEuler} mode:
@list{
@*	Only axes 0 and 2 need to be set. Axis 1 will be determined
	automatically at each time step.
@*	Axes 0 and 2 must be perpendicular to each other.
@*	Axis 0 must be anchored to the first body, axis 2 must be anchored
	to the second body.
}
}

@funcdef{
void dJointSetAMotorAngle (dJointID, int anum, dReal angle);
}{
Tell the AMotor what the current angle is along axis @arg{anum}.
This function should only be called in @c{dAMotorUser} mode, because in this
mode the AMotor has no other way of knowing the joint angles.
The angle information is needed if stops have been set along the axis,
but it is not needed for axis motors.
}

@funcdef{
dReal dJointGetAMotorAngle (dJointID, int anum);
}{
Return the current angle for axis @arg{anum}.
In @c{dAMotorUser} mode this is simply the value that was set with
@func{dJointSetAMotorAngle}.
In @c{dAMotorEuler} mode this is the corresponding euler angle.
}

@funcdef{
dReal dJointGetAMotorAngleRate (dJointID, int anum);
}{
Return the current angle rate for axis @arg{anum}.
In @c{dAMotorUser} mode this is always zero, as not enough information is
available.
In @c{dAMotorEuler} mode this is the corresponding euler angle rate.
}


@section{General}

The joint geometry parameter setting functions should only be called after
the joint has been attached to bodies, and those bodies have been correctly
positioned, otherwise the joint may not be initialized correctly.
If the joint is not already attached, these functions will do nothing.

For the parameter getting functions, if the system is out of alignment
(i.e. there is some joint error) then the anchor/axis values will be correct
with respect to body 1 only (or body 2 if you specified body 1 as zero in the
@func{dJointAttach()} function).

The default anchor for all joints is (0,0,0).
The default axis for all joints is (1,0,0).

When an axis is set it will be normalized to unit length.
The adjusted axis is what the axis getting functions will return.


When measuring a joint angle or position, a value of zero corresponds to the
initial position of the bodies relative to each other.

Note that there are no functions to set joint angles or positions (or their
rates) directly, instead you must set the corresponding body positions and
velocities.


@section{Stop and motor parameters}

When a joint is first created there is nothing to prevent it from
moving through its entire range of motion.
For example a hinge will be able to move through its entire angle,
and a slider will slide to any length.

This range of motion can be limited by setting stops on the joint.
The joint angle (or position) will be prevented from going below the
low stop value, or from going above the high stop value.
Note that a joint angle (or position) of zero corresponds to the
initial body positions.

As well as stops, many joint types can have motors.
A motor applies a torque (or force) to a joint's degree(s) of freedom to
get it to pivot (or slide) at a desired speed.
Motors have force limits, which means they can apply no more than a
given maximum force/torque to the joint.

Motors have two parameters: a desired speed, and the maximum force that is
available to reach that speed.
This is a very simple model of real life motors, engines or servos.
However, is it quite useful when modeling a motor (or engine or servo) that
is geared down with a gearbox before being connected to the joint.
Such devices are often controlled by setting a desired speed, and can only
generate a maximum amount of power to achieve that speed (which corresponds
to a certain amount of force available at the joint).

Motors can also be used to accurately model dry (or Coulomb) friction in
joints.
Simply set the desired velocity to zero and set the maximum force to some
constant value - then all joint motion will be impeded by that force.

The alternative to using joint stops and motors is to simply apply forces
to the affected bodies yourself.
Applying motor forces is easy, and joint stops can be emulated with
restraining spring forces.
However applying forces directly is often not a good approach and can lead
to severe stability problems if it is not done carefully.

Consider the case of applying a force to a body to achieve a desired
velocity.
To calculate this force you use information about the current velocity,
something like this:

	@center{@m{force = k * (desired speed - current speed)}}

This has several problems.
First, the parameter @m{k} must be tuned by hand.
If it is too low the body will take a long time to come up to speed.
If it is too high the simulation will become unstable.
Second, even if @m{k} is chosen well the body will still take a few time steps
to come up to speed.
Third, if any other ``external'' forces are being applied to the body, the
desired velocity may never even be reached (a more complicated force equation
would be needed, which would have extra parameters and its own problems).

Joint motors solve all these problems: they bring the body up to speed
in one time step, provided that does not take more force than is allowed.
Joint motors need no extra parameters because they are actually implemented as
constraints.
They can effectively see one time step into the future to work out the correct
force.
This makes joint motors more computationally expensive than computing the
forces yourself, but they are much more robust and stable, and far less time
consuming to design with.
This is especially true with larger rigid body systems.

Similar arguments apply to joint stops.

@subsection{Parameter functions}

Here are the functions that set stop and motor parameters (as well as other
kinds of parameters) on a joint:


@funcdef{
void dJointSetHingeParam (dJointID, int parameter, dReal value);
void dJointSetSliderParam (dJointID, int parameter, dReal value);
void dJointSetHinge2Param (dJointID, int parameter, dReal value);
void dJointSetAMotorParam (dJointID, int parameter, dReal value);
dReal dJointGetHingeParam (dJointID, int parameter);
dReal dJointGetSliderParam (dJointID, int parameter);
dReal dJointGetHinge2Param (dJointID, int parameter);
dReal dJointGetAMotorParam (dJointID, int parameter);
}{
Set/get limit/motor parameters for each joint type.
The parameter numbers are:

@constdef{dParamLoStop}{Low stop angle or position. Setting this to
	@c{-dInfinity} (the default value) turns off the low stop.
	For rotational joints, this stop must be greater than @m{-Pi} to be
	effective.}
@constdef{dParamHiStop}{High stop angle or position. Setting this to
	@c{dInfinity} (the default value) turns off the high stop.
	For rotational joints, this stop must be less than @m{Pi} to be
	effective.
	If the high stop is less than the low stop then both stops will
	be ineffective.}
@constdef{dParamVel}{Desired motor velocity (this will be an angular or
	linear velocity).}
@constdef{dParamFMax}{The maximum force or torque that the motor will use to
	achieve the desired velocity.
	This must always be greater than or equal to zero.
	Setting this to zero (the default value) turns off the motor.}
@constdef{dParamFudgeFactor}{The current joint stop/motor implementation has
	a small problem:
	when the joint is at one stop and the motor is set to move it away
	from the stop, too much force may be applied for one time step,
	causing a ``jumping'' motion.
	This fudge factor is used to scale this excess force.
	It should have a value between zero and one (the default value).
	If the jumping motion is too visible in a joint, the value can be
	reduced.
	Making this value too small can prevent the motor from being able to
	move the joint away from a stop.}
@constdef{dParamBounce}{The bouncyness of the stops.
	This is a restitution parameter in the range 0..1.
	0 means the stops are not bouncy at all, 1 means maximum bouncyness.}
@constdef{dParamCFM}{The constraint force mixing (CFM) value used when not
	at a stop.}
@constdef{dParamStopERP}{The error reduction parameter (ERP) used by the
	stops.}
@constdef{dParamStopCFM}{The constraint force mixing (CFM) value used by the
	stops. Together with the ERP value this can be used to get spongy or
	soft stops.
	Note that this is intended for unpowered joints, it does not really
	work as expected when a powered joint reaches its limit.}
@constdef{dParamSuspensionERP}{Suspension error reduction parameter (ERP).
	Currently this is only implemented on the hinge-2 joint.}
@constdef{dParamSuspensionCFM}{Suspension constraint force mixing (CFM) value.
	Currently this is only implemented on the hinge-2 joint.}

If a particular parameter is not implemented by a given joint, setting it
will have no effect.

These parameter names can be optionally followed by a digit (2 or 3)
to indicate the second or third set of parameters, e.g. for the second axis
in a hinge-2 joint, or the third axis in an AMotor joint.
A constant @c{dParamGroup} is also defined such that:

@center{@c{dParamX}@m{i} = @c{dParamX} + @c{dParamGroup} * @m{(i-1)}}
}

#############################################################################
@chapter{Support functions}

@section{Rotation functions}

Rigid body orientations are represented with quaternions.
A quaternion is four numbers [cos(theta/2) sin(theta/2)*u] where
theta is a rotation angle and `u' is a unit length rotation axis.

Every rigid body also has a 3x3 rotation matrix that is derived from
the quaternion.
The rotation matrix and the quaternion always match.

Some information about quaternions:
@list{
@*	q and -q represent the same rotation.
@*	The inverse of a quaternion is [ q[0] -q[1] -q[2] -q[3] ].
}

The following are utility functions for dealing with rotation matrices and
quaternions.

@funcdef{
void dRSetIdentity (dMatrix3 R);
}{
Set @arg{R} to the identity matrix (i.e. no rotation).
}

@funcdef{
void dRFromAxisAndAngle (dMatrix3 R,
                         dReal ax, dReal ay, dReal az, dReal angle);
}{
Compute the rotation matrix @arg{R} as a rotation of @arg{angle} radians
along the axis (@arg{ax},@arg{ay},@arg{az}).
}

@funcdef{
void dRFromEulerAngles (dMatrix3 R,
                        dReal phi, dReal theta, dReal psi);
}{
Compute the rotation matrix @arg{R} from the three Euler rotation angles.
}

@funcdef{
void dRFrom2Axes (dMatrix3 R, dReal ax, dReal ay, dReal az,
                  dReal bx, dReal by, dReal bz);
}{
Compute the rotation matrix @arg{R} from the two vectors `a'
(@arg{ax},@arg{ay},@arg{az}) and `b' (@arg{bx},@arg{by},@arg{bz}).
`a' and `b' are the desired x and y axes of the rotated coordinate system.
If necessary, `a' and `b' will be made unit length, and `b' will be
projected so that it is perpendicular to `a'.
The desired z axis is the cross product of `a' and `b'.
}

@funcdef{
void dQSetIdentity (dQuaternion q);
}{
Set @arg{q} to the identity rotation (i.e. no rotation).
}

@funcdef{
void dQFromAxisAndAngle (dQuaternion q, dReal ax, dReal ay, dReal az,
                         dReal angle);
}{
Compute @arg{q} as a rotation of @arg{angle} radians along the axis
(@arg{ax},@arg{ay},@arg{az}).
}

@funcdef{
void dQMultiply0 (dQuaternion qa,
                  const dQuaternion qb, const dQuaternion qc);
void dQMultiply1 (dQuaternion qa,
                  const dQuaternion qb, const dQuaternion qc);
void dQMultiply2 (dQuaternion qa,
                  const dQuaternion qb, const dQuaternion qc);
void dQMultiply3 (dQuaternion qa,
                  const dQuaternion qb, const dQuaternion qc);
}{
Set @arg{qa} = @arg{qb}*@arg{qc}.
This is that same as @arg{qa} = rotation @arg{qc} followed by rotation
@arg{qa}.
The 0/1/2 versions are analogous to the multiply functions, i.e. 1 uses the
inverse of @arg{qb}, and 2 uses the inverse of @arg{qc}.
Option 3 uses the inverse of both.
}

@funcdef{
void dQtoR (const dQuaternion q, dMatrix3 R);
}{
Convert quaternion @arg{q} to rotation matrix @arg{R}.
}

@funcdef{
void dRtoQ (const dMatrix3 R, dQuaternion q);
}{
Convert rotation matrix @arg{R} to quaternion @arg{q}.
}


@funcdef{
void dWtoDQ (const dVector3 w, const dQuaternion q, dVector4 dq);
}{
Given an existing orientation @arg{q} and an angular velocity vector @arg{w},
return in @arg{dq} the resulting dq/dt.
}

#............................................................................
@section{Mass functions}

The mass parameters of a rigid body are described by a @c{dMass} structure:
@code{@[
typedef struct dMass {
  dReal mass;   // total mass of the rigid body
  dVector4 c;   // center of gravity position in body frame (x,y,z)
  dMatrix3 I;   // 3x3 inertia tensor in body frame, about POR
} dMass;
@]}

The following functions operate on this structure:

@funcdef{
void dMassSetZero (dMass *);
}{
Set all the mass parameters to zero.
}

@funcdef{
void dMassSetParameters (dMass *, dReal themass,
                         dReal cgx, dReal cgy, dReal cgz,
                         dReal I11, dReal I22, dReal I33,
                         dReal I12, dReal I13, dReal I23);
}{
Set the mass parameters to the given values.
@arg{themass} is the mass of the body.
(@arg{cx},@arg{cy},@arg{cz}) is the center of gravity position in the body
frame.
The @c{Ixx} values are the elements of the inertia matrix:
@code{
    [ I11 I12 I13 ]
    [ I12 I22 I23 ]
    [ I13 I23 I33 ]
}
}

@funcdef{
void dMassSetSphere (dMass *, dReal density, dReal radius);
}{
Set the mass parameters to represent a sphere of the given radius and
density, with the center of mass at (0,0,0) relative to the body.
}

@funcdef{
void dMassSetCappedCylinder (dMass *, dReal density, int direction,
                             dReal a, dReal b);
}{
Set the mass parameters to represent a capped cylinder of the given parameters
and density, with the center of mass at (0,0,0) relative to the body.
The radius of the cylinder (and the spherical cap) is @arg{a}.
The length of the cylinder (not counting the spherical cap) is @arg{b}.
The cylinder's long axis is oriented along the body's x, y or z axis according
to the value of @arg{direction} (1=x, 2=y, 3=z).
}

@funcdef{
void dMassSetBox (dMass *, dReal density,
                  dReal lx, dReal ly, dReal lz);
}{
Set the mass parameters to represent a box of the given dimensions
and density, with the center of mass at (0,0,0) relative to the body.
The side lengths of the box along the x, y and z axes are @arg{lx}, @arg{ly}
and @arg{lz}.
}

@funcdef{
void dMassAdjust (dMass *, dReal newmass);
}{
Given mass parameters for some object, adjust them so the total mass is
now @arg{newmass}.
This is useful when using the above functions to set the mass parameters for
certain objects - they take the object density, not the total mass.
}

@funcdef{
void dMassTranslate (dMass *, dReal x, dReal y, dReal z);
}{
Given mass parameters for some object, adjust them to represent the object
displaced by (@arg{x},@arg{y},@arg{z}) relative to the body frame.
}

@funcdef{
void dMassRotate (dMass *, const dMatrix3 R);
}{
Given mass parameters for some object, adjust them to represent the object
rotated by @arg{R} relative to the body frame.
}

@funcdef{
void dMassAdd (dMass *a, const dMass *b);
}{
Add the mass @arg{b} to the mass @arg{a}.
}


#............................................................................
@section{Math functions}

[There are quite a lot of these, but they're not standardized enough to
document yet].

#............................................................................
@section{Error and memory functions}

[Document these later].

#############################################################################
@chapter{Collision functions}

This chapter describes the built-in collision detection system of ODE.
Using ODE's collision detection is optional - an alternative collision
detection system can be used as long as it can supply the right kinds
of information to ODE.

@section{Contact points}

If two bodies touch, or if a body touches a static feature in its environment,
the contact is represented by one or more "contact points".
Each contact point has a corresponding @c{dContactGeom} structure:
@code{@[
struct dContactGeom {
  dVector3 pos;       // contact position
  dVector3 normal;    // normal vector
  dReal depth;        // penetration depth
  dGeomID g1,g2;      // the colliding geoms
};
@]}
@arg{pos} records the contact position, in global coordinates.

@arg{depth} is the depth to which the two bodies inter-penetrate each other.
If the depth is zero then the two bodies have a grazing contact, i.e. they
"only just" touch.
However, this is rare - the simulation is not perfectly accurate and will
often step the bodies too far so that the depth is nonzero.

@arg{normal} is a unit length vector that is, generally speaking,
perpendicular to the contact surface.

@arg{g1} and @arg{g2} are the geometry objects that collided.

The convention is that if body 1 is moved along the @arg{normal} vector by a
distance @arg{depth} (or equivalently if body 2 is moved the same distance in
the opposite direction) then the contact depth will be reduced to zero.
This means that the normal vector points "in" to body 1.

In real life, contact between two bodies is a sophisticated thing.
Representing contacts by contact points is only an approximation.
Contact "patches" or "surfaces" might be more physically accurate, but
representing these things in high speed simulation software is a challenge.

Each extra contact point added to the simulation will slow it down some more,
so sometimes we are forced to ignore contact points in the interests of speed.
For example, when two boxes collide many contact points may be needed to
properly represent the geometry of the situation, but we may choose to
keep only the best three. Thus we are piling approximation on top of
approximation.


@section{Geometry objects}

To use ODE's collision detection, geometry objects must be associated with
the rigid bodies.
A geometry object represents a rigid @emph{shape} in space.
Geometry objects are distinct from rigid bodies in that a geometry object
has geometrical properties (size, shape, position and orientation) but no
dynamical properties (such as velocity or mass).

Every geometry object is an instance of a @emph{class}, such as
sphere, plane, or box.
You can define your own classes as well.

Every geometry object has a position vector and a 3*3 rotation matrix.
If a geometry object is associated with a rigid body then its position and
rotation is actually the position and rotation of that body.
The point of reference for the standard classes usually corresponds to their
centers of mass.
This makes them particularly easy to connect to dynamics objects.
If other points of reference are required, transformation objects should be
used to encapsulate the primitives.

@subsection{Sphere class}

@funcdef{
dGeomID dCreateSphere (dSpaceID space, dReal radius);
}{
Create a sphere geometry object of the given @arg{radius}, and return its ID.
If @arg{space} is nonzero, insert it into that space.
The point of reference for a sphere is its center.
}


@funcdef{
void dGeomSphereSetRadius (dGeomID sphere, dReal radius);
}{
Set the radius of the given sphere.
}


@funcdef{
dReal dGeomSphereGetRadius (dGeomID sphere);
}{
Return the radius of the given sphere.
}


@subsection{Box class}

@funcdef{
dGeomID dCreateBox (dSpaceID space, dReal lx, dReal ly, dReal lz);
}{
Create a box geometry object of the given x/y/z side lengths
(@arg{lx},@arg{ly},@arg{lz}), and return its ID.
If @arg{space} is nonzero, insert it into that space.
The point of reference for a box is its center.
}


@funcdef{
void dGeomBoxSetLengths (dGeomID box, dReal lx, dReal ly, dReal lz);
}{
Set the side lengths of the given @arg{box}.
}


@funcdef{
void dGeomBoxGetLengths (dGeomID box, dVector3 result);
}{
Return in @arg{result} the side lengths of the given @arg{box}.
}


@subsection{Plane class}

@funcdef{
dGeomID dCreatePlane (dSpaceID space,
                      dReal a, dReal b, dReal c, dReal d);
}{
Create a plane geometry object of the given parameters, and return its ID.
If @arg{space} is nonzero, insert it into that space.
The plane equation is @center{@m{a*x+b*y+c*z = d}}
The plane's normal vector is @m{(a,b,c)}, and it must have length 1.
Unlike other geometry objects, planes disregard their assigned position and
rotation, i.e. the parameters are always in global coordinates.
In other words it is assumed that the plane is always part of the static
environment and not tied to any movable object.
}


@funcdef{
void dGeomPlaneSetParams (dGeomID plane, dReal a, dReal b, dReal c, dReal d);
}{
Set the parameters of the given @arg{plane}.
}


@funcdef{
void dGeomPlaneGetParams (dGeomID plane, dVector4 result);
}{
Return in @arg{result} the parameters of the given @arg{plane}.
}


@subsection{Capped cylinder class}

@funcdef{
dGeomID dCreateCCylinder (dSpaceID space, dReal radius, dReal length);
}{
Create a capped cylinder geometry object of the given parameters, and return
its ID.
If @arg{space} is nonzero, insert it into that space.

A capped cylinder is like a normal cylinder except it has half-sphere caps
at its ends.
This feature makes collision detection particularly easy.
The cylinder's length, not counting the caps, is given by @arg{length}.
The cylinder is aligned along the geometry's local Z axis.
The radius of the caps, and of the cylinder itself, is given by @arg{radius}.
}


@funcdef{
void dGeomCCylinderSetParams (dGeomID ccylinder,
                              dReal radius, dReal length);
}{
Set the parameters of the given capped cylinder.
}


@funcdef{
void dGeomCCylinderGetParams (dGeomID ccylinder,
                              dReal *radius, dReal *length);
}{
Return in @arg{radius} and @arg{length} the parameters of the given capped
cylinder.
}


@subsection{Geometry Group class}

Geometry object groups (GeomGroups) are a way to speed up collision detection
in some situations.
They represent a collection of geometry objects that are located together
in space.

GeomGroups solve the following problem:
Suppose you have two cars driving over some terrain.
Each car is made up of many bodies.
Without GeomGroups, the collision computation time between the two cars is
proportional to the total number of parts (or even to the square of this
number, depending on which space container is used).
To speed up the process, a GeomGroup object is created to represent each car.
The GeomGroup is inserted into the space, but the individual geometry objects
of the cars are not.
The bounding box of each GeomGroup is computed to encompass the car
geometry objects.
At each time step, the @func{dSpaceCollide()} function does a single
intersection test between the GeomGroups.
If there is an intersection, the contents of the GeomGroup will be
individually tested against each other.
In this way the best case performance (when the cars are far away from
each other) is improved.

GeomGroups have the same interface as any other geometry object.

The geometry objects inside a GeomGroup will not self-intersect if they are
not a member of a space.
If you want them to self-intersect, insert them into a separate space and
call @func{dSpaceCollide()} on that.
Do not insert them into the same space the GeomGroup is in.


@funcdef{
dGeomID dCreateGeomGroup (dSpaceID space);
}{
Create an empty geometry group object, and return its ID.
If @arg{space} is nonzero, insert it into that space.
}


@funcdef{
void dGeomGroupAdd (dGeomID group, dGeomID x);
}{
Add the geometry object @arg{x} to the given GeomGroup.
Note that when the GeomGroup is destroyed, the objects that it contains will
@emph{not} be.
}


@funcdef{
void dGeomGroupRemove (dGeomID group, dGeomID x);
}{
Remove the geometry object @arg{x} from the given GeomGroup.
If it is not in the GeomGroup then nothing is done.
}


@funcdef{
int dGeomGroupGetNumGeoms (dGeomID group);
}{
Return the number of geometry object in the given GeomGroup.
}


@funcdef{
dGeomID dGeomGroupGetGeom (dGeomID group, int i);
}{
Return a specific geometry object from the given GeomGroup.
@arg{i} is the index of the object, it must be between 0 and @m{n-1}
where @m{n} is the number of objects in the group.
}


@subsection{Geometry Transform class}

A geometry transform object (T) encapsulates another geometry object (E),
allowing E to be positioned and rotated arbitrarily with respect to its
point of reference.

Most geometry objects (like the sphere and box) have their point of reference
corresponding to their center of mass, allowing them to be easily connected
to dynamics objects.
Transform objects give you more flexibiliy - for example, you can
offset the center of a sphere, or rotate a cylinder so that its axis
is something else.

T mimics the object E that it encapsulates: T is inserted into a
space and attached to a body as though it was E.
E itself must @emph{not} be inserted into a space or attached to a body.
E's position and rotation are set to constant values that say how it
is transformed @emph{relative} to T.
If E's position and rotation are left at their default values, T will
behave exactly like E would have if you had used it directly.


@funcdef{
dGeomID dCreateGeomTransform (dSpaceID space);
}{
Create a new geometry transform object, and return its ID.
If @arg{space} is nonzero, insert it into that space.
On creation the encapsulated geometry is set to 0.
}


@funcdef{
void dGeomTransformSetGeom (dGeomID g, dGeomID obj);
}{
Set the geometry object that the geometry transform @arg{g} encapsulates.
The object @arg{obj} must not be inserted into any space, and must not be
associated with any body.

If @arg{g} has its clean-up mode turned on, and it already encapsulates
an object, the old object will be destroyed before it is replaced with the
new one.
}


@funcdef{
dGeomID dGeomTransformGetGeom (dGeomID g);
}{
Get the geometry object that the geometry transform @arg{g} encapsulates.
}


@funcdef{
void dGeomTransformSetCleanup (dGeomID g, int mode);
int dGeomTransformGetCleanup (dGeomID g);
}{
Set and get the clean-up mode of geometry transform @arg{g}.
If the clean-up mode is 1, then the encapsulated object will be destroyed
when the geometry transform is destroyed.
If the clean-up mode is 0 this does not happen.
The default clean-up mode is 0.
}


@funcdef{
void dGeomTransformSetInfo (dGeomID g, int mode);
int dGeomTransformGetInfo (dGeomID g);
}{
Set and get the "information" mode of geometry transform @arg{g}.
The mode can be 0 or 1. The default mode is 0.

With mode 0, when a transform object is collided with another object
(using @c{dCollide (tx_geom,other_geom,...)}), the @c{g1} field of the
@c{dContactGeom} structure is set to the geometry object that is
@emph{encapsulated} by the transform object. This value of @c{g1} allows
the caller to interrogate the type of the geometry that is transformed,
but it does not allow the caller to determine the position in global
coordinates or the associated body, as both of these properties are used
differently for encapsulated geometry objects.

With mode 1, the @c{g1} field of the @c{dContactGeom} structure is set
to the transform object itself.
This makes the object appear just like any other kind of geometry object,
as @func{dGeomGetBody()} will return the attached body,
and @func{dGeomGetPosition()} will return the global position.
To get the actual type of the encapsulated geometry in this case,
@func{dGeomTransformGetGeom()} must be used.
}


@subsection{General geometry object functions}

@funcdef{
void dGeomDestroy (dGeomID);
}{
Destroy a geometry object, removing it from any space it is in first.
}


@funcdef{
void dGeomSetData (dGeomID, void *);
void *dGeomGetData (dGeomID);
}{
These functions set and get the user-defined data pointer stored in the
geometry object.
}


@funcdef{
void dGeomSetBody (dGeomID, dBodyID);
dBodyID dGeomGetBody (dGeomID);
}{
These functions set and get the body associated with the geometry object.
Setting the body automatically attaches the position vector and rotation
matrix of the body to the geometry object.
Setting a body ID of zero gives the geometry object its own position and
rotation, independent from any body.
}


@funcdef{
void dGeomSetPosition (dGeomID, dReal x, dReal y, dReal z);
void dGeomSetRotation (dGeomID, const dMatrix3 R);
}{
Set the position vector and rotation matrix of the geometry object.
These functions are analogous to @func{dBodySetPosition()} and
@func{dBodySetRotation()}.
If the geometry object is attached to a body, the body's position / rotation
will also be changed.
}


@funcdef{
const dReal * dGeomGetPosition (dGeomID);
const dReal * dGeomGetRotation (dGeomID);
}{
Return pointers to the geometry object's position vector and rotation matrix.
The returned values are pointers to internal data structures, so the vectors
are valid until any changes are made to the geometry object.
If the geometry object is attached to a body, the body's position / rotation
pointers will be returned, i.e. the result will be identical to calling
@func{dBodyGetPosition()} or @func{dBodyGetRotation()}.
}


@funcdef{
void dGeomGetAABB (dGeomID, dReal aabb[6]);
}{
Return in @arg{aabb} the axis aligned bounding box for the given geometry
object.
}


@funcdef{
dReal *dGeomGetSpaceAABB (dGeomID);
}{
Return a pointer to the axis aligned bounding box that was
precomputed for the given geometry object by the @func{dSpaceCollide()}
function.
This returns 0 if the @func{dSpaceCollide()} function is not currently
being called.
This is much faster than calling @func{dGeomGetAABB()}.
}


@subsection{Composite objects}

Consider the following collision objects: @list{
@*	A table that is made out of a box for the top and a box for each leg.
@*	A branch of a tree that is made out of several capped cylinders
	joined together.
@*	A molecule that has spheres representing each atom.
}
If these objects are meant to be @emph{rigid} then it is necessary to use
a single rigid body to represent each of them.
But there are no single geometry classes that can represent things like a
table or a molecule.
The solution is to use a @emph{composite} collision object that is a
combination of several geometry objects.

No extra functions are needed to manage composite objects: simply create
each component geometry object and attach it to the same body.
To move and rotate the component objects with respect to each other,
use geometry transforms to encapsulate them.
That's all there is to it!

However there is one @emph{caveat}: You should never create a composite
object that will result in collision points being generated very close
together.
For example, consider a table that is made up of a box for the top and four
boxes for the legs.
If the legs are flush with the top, and the table is lying on the ground on
its side, then the contact points generated for the boxes may coincide
where the legs join to the top.
ODE does not currently optimize away coincident contact points, so this
situation can lead to numerical errors and strange behavior.

In this example the table geometry should be adjusted so that the legs are
not flush with the sides, making it much more unlikely that coincident
contact points will be generated.
In general, avoid having different contact surfaces that overlap,
or that line up along their edges.


@section{Collision detection}

@funcdef{
int dCollide (dGeomID o1, dGeomID o2, int flags,
              dContactGeom *contact, int skip);
}{
Given two geometry objects that potentially touch (@arg{o1} and @arg{o2}),
generate contact information for them.
Internally, this just calls the correct class-specific collision functions
for @arg{o1} and @arg{o2}.

@arg{flags} specifies how contacts should be generated if the objects touch.
Currently the lower 16 bits of @arg{flags} specifies the maximum number of
contact points to generate.
If this number is zero, this function just pretends that it is one - in other
words you can not ask for zero contacts.
All other bits in @arg{flags} must be zero.
In the future the other bits may be used to select other contact generation
strategies.

@arg{contact} must point to an array of contact geometry information that
can hold at least the maximum number of contacts.
@emph{Note:} the elements of the @arg{contact} array do not necessarily have
to be contiguous.
@arg{skip} is the number of bytes between each @struct{dContactGeom}
structure in the @arg{contact} array.
If @arg{skip} is @c{sizeof(dContactGeom)} then @arg{contact} points to a
"normal" (C-style) contact array.
If skip is larger than this, then the @struct{dContactGeom} structures are
embedded in some other larger structures.
It is an error for @arg{skip} to be smaller than @c{sizeof(dContactGeom)}.

If the objects touch, this returns the number of contact points generated
(and updates the @arg{contact} array), otherwise it returns 0 (and the
@arg{contact} array is not touched).
}


@section{User defined classes}

You can define your own geometry classes using the functions in this section.
The standard geometry classes do not have any special access to the internals
of ODE, they use the public functions exactly as you would.

Every geometry class has a unique number (0,1,2, etc...).
A new geometry class (call it `X') must provide the following to ODE:
@numlist{
@*	Functions that will handle collision detection and contact generation
	between X and one or more other classes.
	These functions must be of type @c{dColliderFn}, which is defined as
	@code{@[
typedef int dColliderFn (dGeomID o1, dGeomID o2, int flags,
                         dContactGeom *contact, int skip);
	@]}
	This has exactly the same interface as @func{dCollide()}.
	Each function will handle a specific collision case, where @arg{o1}
	has type X and @arg{o2} has some other known type.

@*	A "selector" function, of type @c{dGetColliderFnFn}, which is
	defined as
	@code{@[
typedef dColliderFn * dGetColliderFnFn (int num);
	@]}
	This function takes a class number (@arg{num}), and returns the
	collider function that can handle colliding X with class @arg{num}.
	It should return 0 if X does not know how to collide with class
	@arg{num}.
	Note that if classes X and Y are to collide, only @emph{one} needs
	to provide a function to collide with the other.

	This function is called infrequently - the return values are cached
	and reused.

@*	A function that will compute the axis aligned bounding box (AABB) of
	instances of this class.
	This function must be of type @c{dGetAABBFn}, which is defined as
	@code{@[
typedef void dGetAABBFn (dGeomID g, dReal aabb[6]);
	@]}
	This function is given @arg{g}, which has type X, and returns the
	axis-aligned bounding box for @arg{g}.
	The @arg{aabb} array has elements
	@m{(minx, maxx, miny, maxy, minz, maxz)}.
	If you don't want to compute tight bounds for the AABB, you can just
	supply a pointer to @func{dInfiniteAABB()}, which returns +/- infinity
	in each direction.

@*	The number of bytes of "class data" that instances of this class
	need. For example a sphere stores its radius in the class data area,
	and a box stores its side lengths there.
}
The following things are optional for a geometry class:
@numlist{
@*	A function that will destroy the class data. Most classes will not
	need this function, but some will want to deallocate heap memory
	or release other resources.
	This function must be of type @c{dGeomDtorFn}, which is defined as 
	@code{@[
typedef void dGeomDtorFn (dGeomID o);
	@]}
	The argument @arg{o} has type X.

@*	A function that will test whether a given AABB intersects with an
	instance of X.
	This is used as an early-exit test in the space collision functions.
	This function must be of type @c{dAABBTestFn}, which is defined as 
	@code{@[
typedef int dAABBTestFn (dGeomID o1, dGeomID o2, dReal aabb2[6]);
	@]}
	The argument @arg{o1} has type X.
	If this function is provided it is called by @func{dSpaceCollide()}
	when @arg{o1} intersects geometry object @arg{o2}, which has an
	AABB given by @arg{aabb2}.
	It returns 1 if @arg{aabb2} intersects @arg{o1}, or 0 if it does not.

	This is useful, for example, for large terrains.
	Terrains typically have very large AABBs, which are not very useful to
	test intersections with other objects.
	This function can test another object's AABB against the terrain
	without going to the computational trouble of calling the specific
	collision function.
	This has an especially big savings when testing against GeomGroup
	objects.
}

Here are the functions used to manage custom classes:


@funcdef{
int dCreateGeomClass (const dGeomClass *classptr);
}{
Register a new geometry class, defined by @arg{classptr}.
The number of the new class is returned.
The convention used in ODE is to assign the class number to a global variable
with the name @c{dXxxClass} where Xxx is the class name
(e.g. @c{dSphereClass}).

Here is the definition of the @c{dGeomClass} structure:
@code{@[
struct dGeomClass {
  int bytes;                  // bytes of custom data needed
  dGetColliderFnFn *collider; // collider function
  dGetAABBFn *aabb;           // bounding box function
  dAABBTestFn *aabb_test;     // aabb tester, can be 0 for none
  dGeomDtorFn *dtor;          // destructor, can be 0 for none
};
@]}
}


@funcdef{
void * dGeomGetClassData (dGeomID);
}{
Given a geometry object, return a pointer to the class's custom data
(this will be a block of the required number of bytes).
Internal ODE classes may use a slightly faster macro instead.
}


@funcdef{
dGeomID dCreateGeom (int classnum);
}{
Create a geometry object of the given class number.
The custom data block will initially be set to 0.
This object can be added to a space using @func{dSpaceAdd()}.
}


@funcdef{
int dGeomGetClass (dGeomID);
}{
Given a geometry object, this returns its class number.
}


When you implement a new class you will usually write a function that does
the following:
@numlist{
@*	If the class has not yet been created, create it.
	You should be careful to only ever create the class once.
@*	Call @func{dCreateGeom()} to make an instance of the class.
@*	Set up the custom data area.
}
This is what @func{dCreateSphere()} and the other geometry creation
functions do.


@section{Utility functions}

@funcdef{
void dClosestLineSegmentPoints (dVector3 const a1, dVector3 const a2,
				dVector3 const b1, dVector3 const b2,
				dVector3 cp1, dVector3 cp2)
}{
Given two line segments A and B with endpoints @arg{a1}-@arg{a2} and
@arg{b1}-@arg{b2}, return the points on A and B that are closest to each
other (in @arg{cp1} and @arg{cp2}).
In the case of parallel lines where there are multiple solutions, a solution
involving the endpoint of at least one line will be returned.
This will work correctly for zero length lines, e.g. if @arg{a1}==@arg{a2}
and/or @arg{b1}==@arg{b2}.
}


@funcdef{
int dBoxTouchesBox (const dVector3 _p1, const dMatrix3 R1,
                    const dVector3 side1, const dVector3 _p2,
                    const dMatrix3 R2, const dVector3 side2);
}{
Given boxes (@arg{p1},@arg{R1},@arg{side1}) and
(@arg{p2},@arg{R2},@arg{side2}), return 1 if they intersect or 0 if not.
@arg{p} is the center of the box, @arg{R} is the rotation matrix for
the box, and @arg{side} is a vector of x/y/z side lengths.
}


@funcdef{
void dInfiniteAABB (dGeomID geom, dReal aabb[6]);
}{
This function can be used as the AABB-getting function in a geometry class,
if you don't want to compute tight bounds for the AABB.
It returns +/- infinity in each direction.
}


@section{Space}

A space is a container for geometry objects.
It is similar to the rigid body "world", except for collision instead of
dynamics.

The space does high level collision culling, which means that it can
identify which pairs of geometry objects are potentially touching.
You can safely call @func{dCollide()} for only those pairs, instead of
having to call @func{dCollide()} for @emph{every} object-object pair.
This can save a huge amount of time.

Two collision culling algorithms are currently available:
@list{
@*	Simple. This checks every possible pair of geometry objects for
	intersection, and reports the ones whose AABBs overlap.
	The time required to do intersection testing for @m{n} objects is
	@m{O(n^2)}.
	This should not be used for large numbers of objects, but it can be
	the preferred algorithm for a small number of objects.

@*	Multi-resolution hash table.
	This records how each geometry object overlaps cells in
	one of several three dimensional tables.
	Each tables has cubical cells of different sizes (actually with
	side lengths of @m{2^i}).
	The time required to do intersection testing for @m{n} objects is
	@m{O(n)}, as each object can be quickly paired with the objects
	around it.
}

All spaces guarantee that if a geometry object's collider function is called,
the object's AABB function will have been called prior to that without the
geometry position having being changed in between the calls.
This protocol can be useful if the AABB function wants to precompute some
data that is used by the collider function.
The collider function can check if it is being called inside a space by
checking if the return value of @func{dGeomGetSpaceAABB()} is nonzero.

Here are the functions used for spaces:

@funcdef{
dSpaceID dSimpleSpaceCreate();
dSpaceID dHashSpaceCreate();
}{
Create a space, either of the simple or multi-resolution hash table kind.
}


@funcdef{
void dHashSpaceSetLevels (dSpaceID space, int minlevel, int maxlevel);
}{
This sets some parameters for a multi-resolution hash table space.
The smallest and largest cell sizes used in the hash table will be
2^@arg{minlevel} and 2^@arg{maxlevel} respectively.
}


@funcdef{
void dSpaceDestroy (dSpaceID);
}{
Destroy a space.
When a space is destroyed, all the geometry objects in that space are
automatically destroyed as well.
}


@funcdef{
void dSpaceAdd (dSpaceID, dGeomID);
void dSpaceRemove (dSpaceID, dGeomID);
int dSpaceQuery (dSpaceID, dGeomID);
}{
The first two functions add and remove geometry objects to/from the space.
They may be called by the geometry object creation/deletion functions.
@c{dSpaceQuery()} will return 1 if the given geometry object is in the given
space, 0 if not. It is provided for convenience.
}


@funcdef{
void dSpaceCollide (dSpaceID space, void *data,
                    dNearCallback *callback);
}{
Call a callback function one or more times, for all potentially intersecting
objects in the space.
The @arg{callback} function is of type @c{dNearCallback}, which is defined as:
@code{@[
typedef void dNearCallback (void *data, dGeomID o1, dGeomID o2);
@]}
The @arg{data} variable is passed from @func{dSpaceCollide()} to the
callback function. Its meaning is user defined.
The @arg{o1} and @arg{o2} arguments are the geometry objects that may be near
each other.
The callback function can call @func{dCollide()} on @arg{o1} and @arg{o2},
perhaps first determining whether to collide them at all based on other
information.
}

#############################################################################
@chapter{How to make good simulations}

[just notes for now]

@section{Integrator accuracy and stability}

@list{
@*	integrator will not give exact solution
@*	what is stabilty
@*	integrator types (exp & imp, order)
@*	tradeoff between accuracy, stability and work
}


@section{Behavior may depend on step size}

@list{
@*	smaller step = more accurate, more stable
@*	10*0.1 not the same as 5*0.2
@*	tweak at final frame rate
}


@section{Making things go faster}

What factors does execution speed depend on?
Each joint removes a number of degrees of freedom (DOFs) from the system.
For example the ball and socket removes three, and the hinge removes five.
For each separate group of bodies connected by joints, where:
@list{
@*	@m{m_1} is the number of joints in the group,
@*	@m{m_2} is the total number of DOFs removed by those joints, and
@*	@m{n} is the number of bodies in the group,
}
then the computing time per step for the group is proportional to:
	@center{@m{k_1 O(m_1) + k_2 O(m_2^3) + k_2 O(n)}}

ODE currently relies on factorization of a ``system'' matrix that has one
row/column for each DOF removed (this is where the @m{O(m_2^3)}
comes from).
In a 10 body chain that uses ball and socket joints, roughly 30-40% of the
time is spent filling in this matrix, and 30-40% of the time is spent
factorizing it.

Thus, to speed up your simulation you might consider:
@list{
@*	Using less joints - often small bodies and their associated joints
	can be replaced by purely kinematic ``fakes'' without harming
	physical realism.
@*	Replacing multiple joints with simpler alternatives.
	This will become easier as more specialized joint types are defined.
@*	Using less contacts.
@*	Preferring frictionless or viscous friction contacts (that remove one
	DOF) over Coulomb friction contacts (that remove three DOFs)
	where possible.
}
In the future ODE will implement techniques that scale better with the number
of joints.


@section{Making things stable}

@list{
@*	stiff springs / stiff forces are bad.
@*	hard constraints are good.
@*	dependence on integration timestep.
@*	Use powered joint, joint limits, built-in springs as much as possible,
	avoid explicit forces.
@*	mass ratios - e.g. a whip. Joints that connect large and small masses
	together will have a harder time keeping their error low.
@*	if bodies move faster than is reasonable for the timestep
@*	inetias with long axes
}

Increasing the global CFM will make the system more numerically robust and
less susceptable to stability problems.
It will also make the system look more ``spongy'', so a tradeoff has to be
found.

Redundant constraints (two or more constraints that ``try and do the same
job'') will fight each other and cause stability problems.
The numerical cause of this problem is singularity in the system matrix.
One example of this is if two contacts joints connect the same pair of
bodies at the same point.
Another example is if a virtual hinge joint is created between two bodies
by connecting them with two ball joints, spaced apart along the hinge axis
(this is bad because the two ball joints try to remove six degrees of freedom
from the system, but a real hinge joint would only remove five).

Redundant constraints fight each other and generate strange forces in the
system that can swamp the normal forces.
For example, an affected body might fly around as though it has a life
of its own, with complete disregard for gravity.


@section{Using constraint force mixing (CFM)}

@list{
@*	allow singular configurations
@*	effects: jitter or strange forces due to error amplification,
	LCP solver may go slow
@*	allow compliant joints (this may be unwanted also)
}


@section{Avoiding singularities}

@list{
@*	Singularity occurs when there are more joints than needed to constrain
	the bodies motions.
@*	Multiple (incompatible) joints between bodies, esp joint + contact
	(don't collide objects that are joined together).
@*	increasing CFM
@*	unintentional - box chain on floor, other assemblies
@*	use minimum joints for correct behavior. use correct joints for desired
	behavior
@*	adding global CFM usually helps
}


@section{Other stuff}

@list{
@*	contact jitter when pushed out too far - soln: use softness
@*	keep lengths and masses around 1
@*	LCP solver takes a variable number of iterations (only
	non-deterministic part). if it takes too long, increase global
	CFM, prevent multiple contacts (or similar), and limit high
	ratio of force magnitudes (tree grabbing problem) 
@*	hinge limits outside +/- pi
}

#############################################################################
@chapter{FAQ}

@section{How do I connect a body to the static environment with a joint?}

Use @func{dJointAttach} with arguments @c{(body,0)} or @c{(0,body)}.


@section{Does ODE need or use graphics library X ?}

No. ODE is a computational engine, and is completely independent
of any graphics library.
However the examples that come with ODE use OpenGL,
and most interesting uses of ODE will need some graphics library to
make the simulation visible to the user.
But that's your problem.


@section{Why do my rigid bodies bounce or penetrate on collision?
My restitution is zero!}

Sometimes when rigid bodies collide without restitution, they appear to
inter-penetrate slightly and then get pushed apart so that they only just
touch.
The problem gets worse as the time step gets larger.
What is going on?

The contact joint constraint is only applied after the collision is detected.
If a fixed time step is being used, it is likely that the bodies have
already penetrated when this happens.
The error reduction mechanism will push the bodies apart, but this can
take a few time steps (depending on the value of the ERP parameter).

This penetration and pushing apart sometimes makes the bodies look like they
are bouncing, although it is completely independent of whether restitution
is on or not.

Some other simulators have individual rigid bodies take variable sized
timesteps to make sure bodies never penetrate much.
However ODE takes fixed size steps, as automatically choosing a
non-penetrating step size is problematic for an articulated rigid body
simulator (the entire ARB structure must be stepped to account for the
first penetration, which may result in very small steps).

There are three fixes for this problem:
@list{
@*	Take smaller time steps.
@*	Increase ERP to make the problem less visible.
@*	Do your own variable sized time stepping somehow.
}


@section{How can an immovable body be created?}

In other words, how can you create a body that doesn't move, but that
interacts with other bodies?
The answer is to create a geometry object only, without the corresponding
rigid body object.
The geometry object is associated with a rigid body ID of zero.
Then in the contact callback when you detect a collision between two geometry
objects with a nonzero body ID and a zero body ID, you can simply pass those
two IDs to the @func{dJointAttach()} function as normal.
This will create a contact between the rigid body and the static environment.

Don't try to get the same effect by setting a very high mass/inertia on the
``motionless'' body and then resetting it's position/orientation on each
time step.
This can cause unexpected simulation errors.


@section{Why would you ever want to set ERP less than one?}

From the definition of the ERP value, it seems than setting it to one is the
best approach, because then all joint errors will be fully corrected at
each time step.
However, ODE uses various approximations in its integrator, so ERP=1 will not
usually fix 100% of the joint error.
ERP=1 can work in some cases, but it can also result in instability in some
systems.
In these cases you have the option of reducing ERP to get a better behaving
system.


@section{Is it advisable to set body velocities directly, instead of
applying a force or torque?}

You should only set body velocities directly if you are setting the system
to some initial configuration.
If you are setting body velocities every time step (for example from motion
capture data) then you are probably abusing your physical model, i.e. forcing
the system to do what you want rather than letting it happen naturally.

The preferred method of setting body velocities during the simulation is to
use joint motors.
They can set body velocities to a desired value in one time step, provided
that the force/torque limit is high enough.


@section{Why, when I set a body's velocity directly, does it come up to speed
slower when joined to other bodies?}

What is likely happening is that you are setting the velocity of one
body without also setting the velocity of the bodies that it is joined to.
When you do this, you cause error in the system in subsequent time steps
as the bodies come apart at their joints.
The error reduction mechanism will eventually correct for this and pull the
other bodies along, but it may take a few time steps and it will cause a
noticeable "drag" on the original body.

Setting the velocity of a body will affect that body alone.
If it is joined to other bodies, you must set the velocity of each one
separately (and correctly) to prevent this behavior.


@section{Should I scale my units to be around 1.0 ?}

Say you need to simulate some behavior on the scale of a few millimeters
and a few grams.
These small lengths and masses will usually work in ODE with no problem.
However occasionally you may experience stability problems that are caused
by lack of precision in the factorizer.
If this is the case, you can try scaling the lengths and masses in your
system to be around 0.1..10.
The time step should also be be scaled accordingly.
The same guideline applies when large lengths and masses are being used.

In general, length and mass values around 0.1..1.0 are better as the
factorizer may not lose so much precision.
This guideline is especially helpful when single precision is being used.


@section{I've made a car, but the wheels don't stay on properly!}

If you are building a car simulation, typically you create a chassis body
and attach four wheel bodies. However, you may discover that when you drive
it around the wheels rotate in incorrect directions, as though the joint
was somehow becoming ineffective.
The problem is observed when the car is moving fast (so the wheels are
rotating fast), and the car tries to turn a corner.
The wheels appear to rotate off their proper constraints as though the
``axles'' had become bent.
If the wheels are rotating slowly, or the turn is made slowly, the problem
is less apparent.

The problem is that numerical errors are being caused by the high rotation
speed of the wheels.
Two functions are provided to fix this problem:
@func{dBodySetFiniteRotationMode()} and @func{dBodySetFiniteRotationAxis()}.
The wheel bodies should have their finite rotation mode set, and the
wheel's finite rotation axes should be set every time step to match their
hinge axes.
This will hopefully fix most of the problem.


@section{How do I make ``one way'' collision interaction}

Suppose you need to have two bodies (A and B) collide.
The motion of A should affect the motion of B as usual, but B
should not influence A at all.
This might be necessary, for example, if B is a physically simulated camera
in a VR environment.
The camera needs collison response so that it doesn't enter into any scene
objects by mistake, but the motion of the camera should not affect the
simulation.
How can this be achieved?

Here is a good solution: when the collision is detected, don't create a
contact joint between A and B as you normally would.
Instead, attach the contact joint between B and 0 (the static environment).
That way the body A will appear to B as though it is static and unmovable.
This approach may result in some penetration between A and B, but
this will not be a problem in many applications.


@section{The Windows version of ODE crashes with large systems}

ODE requires stack space roughly on the order of @m{O(n)+O(m^2)},
where @m{n} is the number of bodies and @m{m} is the sum of all the joint
constraint dimensions.
If @m{m} is large, this can be a lot of space!

Unix-like operating systems typically allocate stack space as it is needed,
with an upper limit that might be in the hundreds of Mb.
Windows compilers normally allocate a much smaller stack.
If you experience crashes when running large systems, try increasing the
stack size.
For example, the MS VC++ command line compiler accepts the @c{/Stack:num}
flag to set the upper limit.


@section{My simple rotating bodies are unstable!}

If you have a box whose sides have different lengths, and you start it
rotating in free space, you should observe that it just tumbles at the same
speed forever.
But sometimes in ODE the box will gain speed by itself, spinning faster and
faster until it ``explodes'' (disappears off to infinity).
Here is the explanation:

ODE uses a first order semi-implicit integrator.
The ``semi implicit'' means that some forces are calculated as though an
implicit integrator is being used, and other forces are calculated as though
the integrator is explicit.
The constraint forces (applied to bodies to keep the constraints together)
are implicit, and the "external" forces (applied by the user, and due to
rotational effects) are explicit.
Now, inaccuracy in implicit integrators is manifested as a reduction in
energy - in other words the integrator damps the system for you.
Inaccuracy in explicit integrators has the opposite effect - it increases the
system energy.
This is why systems simulated with explicit first order integrators can
explode.

So, a single body tumbling in space is effectively explicitly integrated.
If the body's moments of inertia were equal (e.g. if it is a sphere) then the
rotation axis will remain constant, and the integrator error will be small.
If the body's moments of inertia are unequal then the rotation axis wobbles
as momentum is transferred between different rotation directions.
This is the correct physical behavior, but it results in higher integrator
error.
The integrator in this case is explicit so the error increases the energy,
which causes faster and faster rotation, causing more and more error -
leading to the explosion.
The problem is particularly evident with long thin objects, where the 3
moments of inertia are highly unequal.

To prevent this, do one or more of the following:
@list{
@*	Make sure freely rotating bodies are dynamically symmetric (i.e. all
	moments of inertia are the same - the inertia matrix is a constant
	times the identity matrix).
	Note that you can still render and collide with a long thin box even
	though it has the inertia of a sphere.
@*	Make sure freely rotating bodies don't spin too fast (e.g. don't
	apply large torques, or supply extra damping forces).
@*	Add extra damping elements to the environment, e.g. don't use bouncy
	collisions that can reflect energy.
@*	Use smaller timesteps. This is bad for two reasons: it's slower,
	and ODE currently only has a first order integrator so the added
	accuracy is minimal.
@*	Use a higher order integrator. This is not yet an option in ODE.
}

In the future I may add a feature to ODE to modify the rotational dynamics
of selected bodies so that they exhibit no rotational error with ODEs
integrator.

#############################################################################
@chapter{Known BUGS}

@list{
@*	When assigning a mass to a rigid body, the center of mass must be
	(0,0,0) relative to the body's position.
}

#############################################################################
@chapter{ODE internals}

[only notes for now]

@list{

@*	Internally, all 6x1 spatial velocities and accelerations are split
	into 3x1 position and angular components, which are stored as
	contiguous 4x1 vectors.

@*	Lagrange multiplier velocity based model due to Trinkle and Stewart.
@*	Friction due to Baraff.

@*	Stability over accuracy.

@*	Talk about the different methods possible.
	Say how realtime constraints make the problem much more difficult.

@*	Factorizer.

@*	LCP solver.

@*	Equations of motion.

@*	Friction model and approximations.
}

Why don't I implement a proper friction pyramid or friction cone
(e.g. Baraff's version) ?}
	Because I have to factor non-symmetric (and possibly indefinite)
	matrices, for either static or dynamic friction.
	Speed was considered more important - the current friction
	approximation only needs a symmetric factorization, which is twice
	as fast.


@section{Matrix storage conventions}

Matrix operations like factorization are expensive, so we must store the data
in a way that is most useful to the matrix code.
I want to do 4-way SIMD optimizations later, so the format is this: store
the matrix by rows, and each row is rounded up to a multiple of 4 elements.
The extra "padding" elements at the end of each row/column must be set
to 0.
This is called the "standard format".
Hopefully this decision will remain good in the future, as more and
more processors have 4-way SIMD (especially for fast 3D graphics).

The exception: matrices that have only one column or row (vectors), are always
stored as consecutive elements in standard row format, i.e. there is no
interior padding, only padding at the end.

Thus: all 3x1 floating point vectors are stored as 4x1 vectors: (x,x,x,0).


@section{Internals FAQ}


@subsection{Why do some structures have a @c{dx} prefix and some have a
@c{d} prefix?}

The @c{dx} prefix is used for internal structures that should never be
visible externally.
The @c{d} prefix is used for structures that are part of the public
interface.


@subsection{Returned vectors}

There seem to be 2 ways of returning vectors in ODE, e.g.:
@code{@[
    const dReal* dBodyGetPosition (dxBodyID);
    void dWorldGetGravity (dxWorldID, dVector3);
@]}
Why?
The second way is the 'official' way.
The first way returns pointers to volatile internal data structures and is
less clean API-wise.
For a stable API I feel that filling in vectors is cleaner than returning
pointers to vectors, for two reasons:
@numlist{
@*	The returned vector values may have to be calculated somehow, so
	there is no internal ``cache'' to return a pointer to.
@*	The internal data structures may be moved, which is a problem if
	the user keeps the returned pointer and uses it later.
}
As it happens these two cases don't currently happen in ODE - most returned
vector data is cached and always at the same address.
But having the freedom to change things in the future is useful.
The current API shouldn't slow you down because the cases where you need to
be fast (i.e. getting body transforms) return pointers anyway - breaking my
own rule.
